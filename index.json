[{"categories":null,"content":"Second week of LeetCode Challenge. Participated the virtual contest. ","date":"Oct 2 2019","objectID":"/lc-week-2/:0:0","tags":["LeetCode"],"title":"LeetCode Weekly Contest 156 and others","uri":"/lc-week-2/"},{"categories":null,"content":"Weekly Contest 156 ","date":"Oct 2 2019","objectID":"/lc-week-2/:1:0","tags":["LeetCode"],"title":"LeetCode Weekly Contest 156 and others","uri":"/lc-week-2/"},{"categories":null,"content":"1207. Unique Number of Occurrences https://leetcode.com/contest/weekly-contest-156/problems/unique-number-of-occurrences/ Brute force. Record total occurrence of each number and iterate over it to see if there is any duplication. class Solution { public: bool uniqueOccurrences(vector\u003cint\u003e\u0026 arr) { unordered_map\u003cint, int\u003e occ; unordered_map\u003cint, bool\u003e flag; for (int i = 0; i \u003c arr.size(); ++i) { occ[arr[i]]++; } for (const auto x : occ) { if (flag.find(x.second) != flag.end()) { if (flag[x.second]) return false; } else { flag[x.second] = true; } } return true; } }; ","date":"Oct 2 2019","objectID":"/lc-week-2/:1:1","tags":["LeetCode"],"title":"LeetCode Weekly Contest 156 and others","uri":"/lc-week-2/"},{"categories":null,"content":"1208. Get Equal Substrings Within Budget https://leetcode.com/contest/weekly-contest-156/problems/get-equal-substrings-within-budget/ Two pointers. Let’s think it in this way: at the starting position, if we can go to the next character in the string and does not exceed the maximum cost, do so and keep doing it until we can’t. Then in order to extend the length of sub-string, we must “release” the cost of changing one character at the beginning of the sub-string, so that the next character has some costs available to use in order to hold the maximum bound. class Solution { public: int equalSubstring(string s, string t, int maxCost) { int maxi = -1; int total_cost = 0; int l = 0, r = 0; while (r \u003c t.size()) { int c = abs(s[r]-t[r]); while ((total_cost + c) \u003c= maxCost) { total_cost += c; r++; if (r \u003e= s.size()) break; c = abs(s[r]-t[r]); } maxi = max(maxi, r-l); total_cost -= abs(s[l] - t[l]); l++; } return maxi; } }; ","date":"Oct 2 2019","objectID":"/lc-week-2/:1:2","tags":["LeetCode"],"title":"LeetCode Weekly Contest 156 and others","uri":"/lc-week-2/"},{"categories":null,"content":"1209. Remove All Adjacent Duplicates in String II https://leetcode.com/contest/weekly-contest-156/problems/remove-all-adjacent-duplicates-in-string-ii/ Stack approach. Whenever encounter a new character, push the character with count 1 into the stack. Increment the counter if the next character is the same as the top of the stack. If the counter reaches k, then just remove it from the stack as it’s valid adjacent duplicates. class Solution { public: string removeDuplicates(string s, int k) { int s_size = s.size(); if (s_size \u003c= 1) return s; string ans; stack\u003cpair\u003cchar, int\u003e \u003e stk; stk.push({s[0], 1}); for (int i = 1; i \u003c s_size; i++) { if (!stk.empty() \u0026\u0026 stk.top().first == s[i]) { stk.top().second++; if (stk.top().second == k) { stk.pop(); } } else { stk.push({s[i], 1}); } } while (!stk.empty()) { pair\u003cchar, int\u003e p = stk.top(); stk.pop(); ans += string(p.second, p.first); } reverse(ans.begin(), ans.end()); return ans; } }; ","date":"Oct 2 2019","objectID":"/lc-week-2/:1:3","tags":["LeetCode"],"title":"LeetCode Weekly Contest 156 and others","uri":"/lc-week-2/"},{"categories":null,"content":"1210. Minimum Moves to Reach Target with Rotations https://leetcode.com/contest/weekly-contest-156/problems/minimum-moves-to-reach-target-with-rotations/ BFS. This question is not hard while you got the implementation right. Check all possible moves. class Solution { typedef pair\u003cint, int\u003e block_t; typedef pair\u003cblock_t, block_t\u003e block2_t; typedef pair\u003cblock2_t, int\u003e state_t; // step public: int minimumMoves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int N = grid.size(); queue\u003cstate_t\u003e q; q.push({{{0, 0}, {0, 1}}, 0}); set\u003cblock2_t\u003e visited; visited.insert({{0, 0}, {0, 1}}); pair\u003cset\u003cblock2_t\u003e::iterator, bool\u003e rst; while (!q.empty()) { state_t s = q.front(); q.pop(); block_t a = s.first.first; block_t b = s.first.second; int step = s.second; if (a.first == b.first) { // horizontal if (a.first == N-1 \u0026\u0026 a.second == N-2 \u0026\u0026 b.first == N-1 \u0026\u0026 b.second == N-1) { return step; } if (b.second+1 \u003c N \u0026\u0026 grid[b.first][b.second+1] == 0){ // right rst = visited.insert({{b.first, b.second}, {b.first, b.second+1}}); if (rst.second) { q.push({{{b.first, b.second}, {b.first, b.second+1}}, step+1}); } } if (a.first+1 \u003c N \u0026\u0026 grid[a.first+1][a.second] == 0 \u0026\u0026 grid[b.first+1][b.second] == 0) { // down rst = visited.insert({{a.first+1, a.second}, {b.first+1, b.second}}); if (rst.second) { q.push({{{a.first+1, a.second}, {b.first+1, b.second}}, step+1}); } // clockwise rst = visited.insert({{a.first, a.second}, {a.first+1, a.second}}); if (rst.second) { q.push({{{a.first, a.second}, {a.first+1, a.second}}, step+1}); } } } else { // vertical if (b.first+1 \u003c N \u0026\u0026 grid[b.first+1][b.second] == 0){ // down rst = visited.insert({{b.first, b.second}, {b.first+1, b.second}}); if (rst.second) { q.push({{{b.first, b.second}, {b.first+1, b.second}}, step+1}); } } if (a.second+1 \u003c N \u0026\u0026 grid[a.first][a.second+1] == 0 \u0026\u0026 grid[b.first][b.second+1] == 0) { // right rst = visited.insert({{a.first, a.second+1}, {b.first, b.second+1}}); if (rst.second) { q.push({{{a.first, a.second+1}, {b.first, b.second+1}}, step+1}); } // anti-clockwise rst = visited.insert({{a.first, a.second}, {a.first, a.second+1}}); if (rst.second) { q.push({{{a.first, a.second}, {a.first, a.second+1}}, step+1}); } } } } return -1; } }; ","date":"Oct 2 2019","objectID":"/lc-week-2/:1:4","tags":["LeetCode"],"title":"LeetCode Weekly Contest 156 and others","uri":"/lc-week-2/"},{"categories":null,"content":"This is the first week of LeetCode Challenges. It includes weekly contest 155 and other problems. ","date":"Sep 19 2019","objectID":"/lc-week-1/:0:0","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"Weekly Contest 155 https://leetcode.com/contest/weekly-contest-155 ","date":"Sep 19 2019","objectID":"/lc-week-1/:1:0","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"1200. Minimum Absolute Difference https://leetcode.com/contest/weekly-contest-155/problems/minimum-absolute-difference/ Brute force. Find the minimum absolute difference and then iterate the list again to output the pairs with minimum absolute difference. class Solution { public: vector\u003cvector\u003cint\u003e\u003e minimumAbsDifference(vector\u003cint\u003e\u0026 arr) { vector\u003cvector\u003cint\u003e\u003e ans; if (arr.size() == 1) return ans; sort(arr.begin(), arr.end()); int mini = 0x3f3f3f3f; for (int i = 1; i \u003c arr.size(); ++i) { mini = min(mini, abs(arr[i] - arr[i-1])); } for (int i = 1; i \u003c arr.size(); ++i) { if (abs(arr[i]- arr[i-1]) == mini) { if (arr[i] \u003c arr[i-1]) { ans.push_back({arr[i], arr[i-1]}); } else { ans.push_back({arr[i-1], arr[i]}); } } } return ans; } }; ","date":"Sep 19 2019","objectID":"/lc-week-1/:1:1","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"1201. Ugly Number III https://leetcode.com/contest/weekly-contest-155/problems/ugly-number-iii/ Binary search + inclusion/exclusion principle. The number of integers that is divisible by A and B is equal to the number of integers divisible by A plus the number of integers divisible by b and minus the number of integers divisible by both A and B. The theory can be applied to the case when it is divisible by three numbers. Also, the range of n is $[1, 2 \\cdot 10^9]$, the time complexity of binary search is $\\log_2(2 \\cdot 10^9)$, which is totally feasible. typedef long long LL; class Solution { LL gcd(LL x, LL y) { return (y == 0 ? x : gcd(y, x % y)); } LL lcm(LL x, LL y) { return x / gcd(x, y) * y; } public: LL nthUglyNumber(LL n, LL a, LL b, LL c) { LL l = 1, r = 2e9, mid, cnt; LL lcm_ab = lcm(a, b); LL lcm_ac = lcm(a, c); LL lcm_bc = lcm(b, c); LL lcm_abc = lcm(lcm_ab, c); while (l \u003c r) { mid = (l+r)/2; cnt = mid/a + mid/b + mid/c - mid/lcm_ab - mid/lcm_ac - mid/lcm_bc + mid/lcm_abc; if (cnt \u003c n) { l = mid+1; } else { r = mid; } } return l; } }; ","date":"Sep 19 2019","objectID":"/lc-week-1/:1:2","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"1202. Smallest String With Swaps https://leetcode.com/contest/weekly-contest-155/problems/smallest-string-with-swaps/ Union find. We can find that if it is swappable for the letters at index (1,2) and (2,5), the letters at 1, 2, 5 can be in arbitrary order. Having said that, we can use union find to group them together, then append the character with the smallest lexicographical order in each group. class Solution { const static int MAXN = 1e5+5; int par[MAXN]; int rk[MAXN]; int find(int x) { return (par[x] == x ? x : par[x] = find(par[x])); } void unite(int x, int y) { x = find(x); y = find(y); if (x == y) return ; if (rk[x] \u003c rk[y]) { par[x] = y; } else { par[y] = x; if (rk[x] == rk[y]) rk[x]++; } } public: string smallestStringWithSwaps(string s, vector\u003cvector\u003cint\u003e\u003e\u0026 pairs) { int n = s.size(); for (int i = 0; i \u003c n; ++i) { par[i] = i; rk[i] = 0; } for (int i = 0; i \u003c pairs.size(); ++i) { unite(pairs[i][0], pairs[i][1]); } string ans; unordered_map\u003cint, string\u003e m; for (int i = 0; i \u003c n; ++i) { m[find(i)].push_back(s[i]); } for (auto \u0026x : m) { sort(x.second.begin(), x.second.end()); } for (int i = 0; i \u003c n; ++i) { ans += m[find(i)][0]; m[find(i)].erase(0, 1); } return ans; } }; ","date":"Sep 19 2019","objectID":"/lc-week-1/:1:3","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"1203. Sort Items by Groups Respecting Dependencies https://leetcode.com/contest/weekly-contest-155/problems/sort-items-by-groups-respecting-dependencies/ Topological sort twice. Firstly, we give distinct group numbers to items that do not belong to any of the group, instead of using -1. Then we perform topological sort on the groups only. We only care about the edges among groups and ignore edges within each group. After that, we iterate over each group and perform topological sort within each group. class Solution { public: vector\u003cint\u003e sortItems(int n, int m, vector\u003cint\u003e\u0026 group, vector\u003cvector\u003cint\u003e\u003e\u0026 beforeItems) { // independent element belongs to its own group for (int i = 0; i \u003c group.size(); ++i) { if (group[i] \u003c 0) group[i] = m++; } vector\u003cvector\u003cint\u003e \u003e group_edge(m), within_group_edge(n); vector\u003cint\u003e group_deg(m), within_group_deg(n); for (int i = 0; i \u003c n; ++i) { for (const auto\u0026 y : beforeItems[i]) { if (group[i] == group[y]) { within_group_edge[y].push_back(i); within_group_deg[i]++; } else { group_edge[group[y]].push_back(group[i]); group_deg[group[i]]++; } } } // topo sort groups vector\u003cint\u003e topo; queue\u003cint\u003e q; for (int i = 0; i \u003c m; ++i) { if (group_deg[i] == 0) q.push(i); } while (!q.empty()) { int u = q.front(); q.pop(); for (const auto\u0026 v : group_edge[u]) { group_deg[v]--; if (group_deg[v] == 0) { q.push(v); } } topo.push_back(u); } if (topo.size() != m) return {}; // topo sort within each group vector\u003cint\u003e ans; vector\u003cvector\u003cint\u003e \u003e group_member(m); for (int i = 0; i \u003c n; ++i) { group_member[group[i]].push_back(i); } for (const auto\u0026 g : topo) { queue\u003cint\u003e q2; vector\u003cint\u003e topo2; for (const auto\u0026 x : group_member[g]) { if (within_group_deg[x] == 0) q2.push(x); } while (!q2.empty()) { int u = q2.front(); q2.pop(); for (const auto\u0026 v : within_group_edge[u]) { within_group_deg[v]--; if (within_group_deg[v] == 0) { q2.push(v); } } topo2.push_back(u); } if (topo2.size() != group_member[g].size()) return {}; for (const auto\u0026 x : topo2) { ans.push_back(x); } } return ans; } }; ","date":"Sep 19 2019","objectID":"/lc-week-1/:2:0","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"LeetCode 8 - String to Integer (atoi) https://leetcode.com/problems/string-to-integer-atoi/ This question is a bit odd. Test cases like +-123 are not explicitly stated in the description of the problem. The tricky part is to check the condition of overflow. Note that the last digits of INT_MAX is 7, don’t forget to check. ","date":"Sep 19 2019","objectID":"/lc-week-1/:3:0","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"Solution class Solution { public: int myAtoi(string str) { int sign = 1; int ans = 0; int i = 0; while (isspace(str[i])) ++i; if (str[i] == '+' || str[i] == '-') { sign = (str[i++] == '+' ? 1 : -1); } for (; i \u003c str.size(); ++i) { if (str[i] \u003e= '0' \u0026\u0026 str[i] \u003c= '9') { if (ans \u003e INT_MAX/10 || (ans == INT_MAX/10 \u0026\u0026 str[i] \u003e '7')) { return (sign==1 ? INT_MAX : INT_MIN); } ans *= 10; ans += (str[i]-'0'); } else { break; } } return sign*ans; } }; ","date":"Sep 19 2019","objectID":"/lc-week-1/:3:1","tags":["LeetCode"],"title":"LeetCode Weekly Contest 155 and others","uri":"/lc-week-1/"},{"categories":null,"content":"A command line dictionary written in Perl using Merriam-Webster APIs. This is my first project using Perl. I feel it is tedious to type formatted definitions to Quizlet(A website which can make flashcards for you) and I’m too lazy to open browser and online dictionary pages. Why not combining these two? It uses following APIs: Merriam-Webster Learner Merriam-Webster Collegiate For each entry, it contains: Pronunciation: IPA(International Phonetic Alphabet) Part of Speech Grammar Definition Common Usage Examples All searched words are saved in a set and saved to searched.txt. It also save searched words and definitions into the file quizlet.txt so that they can be imported into Quizlet which makes flashcards. The format is: between term and definition: $ between cards: --- ","date":"Jul 4 2018","objectID":"/cldictp/:0:0","tags":["Perl"],"title":"CLDictP: A Command-Line Dictionary Tool","uri":"/cldictp/"},{"categories":null,"content":"Usage Get API Keys: DictionaryAPI. Add API Keys to api_template.json and change the file name to api.json. Install dependencies with $ cpan Term::ANSIColor Term::ReadKey LWP::UserAgent LWP::Protocol::https Readonly XML::LibXML JSON::XS Data::Dumper Set::Light Run the script with $ perl dict.pl To exit, use Ctrl+D. ","date":"Jul 4 2018","objectID":"/cldictp/:1:0","tags":["Perl"],"title":"CLDictP: A Command-Line Dictionary Tool","uri":"/cldictp/"},{"categories":null,"content":"Demo ","date":"Jul 4 2018","objectID":"/cldictp/:2:0","tags":["Perl"],"title":"CLDictP: A Command-Line Dictionary Tool","uri":"/cldictp/"},{"categories":null,"content":"Source Files The source files are hosted on Github. ","date":"Jul 4 2018","objectID":"/cldictp/:3:0","tags":["Perl"],"title":"CLDictP: A Command-Line Dictionary Tool","uri":"/cldictp/"},{"categories":null,"content":"Static Linked List is a data structure that stores linked list in static arrays. It is usually used to represent graphs. It is very interesting that its Chinese name literally translated as “Linked Forward Star”. You have two choices of paths to understand this. Start from Forward Star. Start from Adjacency List. However, I would recommend to explore both ideas to have a better understanding. If you know some of it or you just don’t care, you can jump to here straight away. ","date":"May 29 2018","objectID":"/static-linked-list/:0:0","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"Forward Star Forward Star is also known as Adjacency Array and . We first store edges in an array and then sorted it. Then we have another two arrays stores the index of each vertex, and out-degree (how many edges are coming from the vertex) respectively. ","date":"May 29 2018","objectID":"/static-linked-list/:1:0","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"Example We have these edges (from, to) in the example graph: (1, 2) (2, 4) (3, 4) (1, 3) (4, 3) (3, 2) (1, 4) Let u be the vertex where the edge is coming from and v be the vertex the edge is going to: We sort it first base on u, the order of v does not matter and we fill arrays es[]: the second vertex in each pair - v. head[]: the index of the first occurrence of u (first vertex in the pair) len[]: how many edges are going out from this vertex (1, 2) --| (1, 3) --| =\u003e len[1] = 3 (1, 4) --| (2, 4) (3, 2) =\u003e head[3] = 5 (3, 4) (4, 3) ^ es[] Array 1 2 3 4 5 6 7 es 2 3 4 4 2 4 3 head 1 4 5 7 len 3 1 2 1 Therefore, we can easily get all edges coming from vertex 1 by first identifying that its index in es[] is 1 using head[1] == 1, and then iterate es[] from head[1] to head[1]+len[1] (exclusive). That is es[1+0] == 2, es[1+1] == 3, es[1+2] == 4 which means the edges (1,2), (1,3), (1,4). // to find all edges from vertex u for (int i = 0; i \u003c len[u]; i++) { cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c es[head[u]+i] \u003c\u003c endl; } Forward Star is not frequently used because of its sorting operation which takes $ O(E \\times log(E)) $ in time complexity. Therefore we have Linked Forward Star to avoid sorting. ","date":"May 29 2018","objectID":"/static-linked-list/:1:1","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"Adjacency List Adjacency List is usually implemented by vector\u003cint\u003e G[MAXN_V]. G[u] points to a vector that stores all edges from u. ","date":"May 29 2018","objectID":"/static-linked-list/:2:0","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"Example The result is like the figure shown below, the array at the left represents each G[] respectively. Every time we read a edge from u, we push it back to the vector G[u] points to. for (int i = 0; i \u003c G[u].size(); i++) { cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c G[u][i] \u003c\u003c endl; } ","date":"May 29 2018","objectID":"/static-linked-list/:2:1","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"Static Linked List Static Linked List is an improved version of Forward Star and the static version of Adjacency List. It avoids sorting the edge array. How? Keep linking to itself! ","date":"May 29 2018","objectID":"/static-linked-list/:3:0","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"Example We use the same example as above. With edges (from, to): (1, 2) (2, 4) (3, 4) (1, 3) (4, 3) (3, 2) (1, 4) ^ es[] We construct arrays, let u be the vertex where the edge is coming from and v be the vertex the edge is going to: es[]: stores vs, containing the second vertices from each pair. The information about u is stored in head[]. head[]: the index of first occurrence of the u, or in other words, the first element of the list. next[]: the index of the next edge that coming from the same u, use 0 to represent that it is the end of the list. During constructing next[], we need another array to keep track of the position of the last element in each list. Or we can update the head[] constantly and store in reverse order. So we have Array 1 2 3 4 5 6 7 es 2 4 4 3 3 2 4 head 1 2 3 5 next 4 0 6 7 0 0 0 Let’s walking through finding all edges coming from vertex 1. use head[1] == 1 and let i = head[1] to find the index of first edge, es[i] == 2 yields the edge (1, 2), update i = next[i], now i == 4. es[i] == 3 yields the edge (1, 3), update i = next[i], now i == 7. es[i] == 4 yields the edge (1, 4), update i = next[i], now i == 0. since i == 0, terminate. for (int i = head[u]; i; i = next[i]) { cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c es[i] \u003c\u003c endl; } It keeps linking back to itself and bounce between es[] and next[], except the first time which uses head[]. ","date":"May 29 2018","objectID":"/static-linked-list/:3:1","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"Comparison The time complexity of Forward Star is $O(E \\times log(E))$, so if you solve problem use this it may become worse. Adjacency List is easy to understand and implement using C++ STL vector. It allocates spaces dynamically, so it does not need to know the number of edges. However, please note that since it allocates twice of the memory as needed, it sometimes wastes some of the space. Static Linked List does not change the order of the edges. It only build up relationships by using arrays. It is faster than STL. It is easy to implement once you master it. However, these data structures are not good at finding particular edges from a given vertex, the worst case is to iterate to the end of the list. ","date":"May 29 2018","objectID":"/static-linked-list/:4:0","tags":["Graph","Data-Structure"],"title":"Static Linked List - Another Way To Represent Graphs","uri":"/static-linked-list/"},{"categories":null,"content":"There are \\(M \\times N\\) \\((1 \\le M, N \\le 15)\\)square tiles. Each tile can be flipped and the color of tile can change between black(1) and white(0). When you flip a tile, 4 adjacent tiles will also be flipped. Note that the four adjacent flipped tiles will NOT cause their adjacent tiles to flip. Given a configuration, find the minimum number of flips so that all square tiles become white. If having the minimum number is the same, choose the least lexicographical one1. If there is no solution, print “IMPOSSIBLE”. Link: http://poj.org/problem?id=3279 1 lexicographical order: When you read from left to right, compare each of character of them, see which one is less in alphabetically order. For example, \\(AA \\lt AB \\lt BA \\lt BB\\). In this case, we read from left to right, up to down 0 0 0 0 0 0 1 0 0 0 0 0 \u003c 1 1 1 \u003c 0 0 0 0 0 0 1 1 1 0 0 0 ⚠️THINK HARDER ","date":"Apr 23 2018","objectID":"/poj-3279/:0:0","tags":["POJ"],"title":"POJ 3279 Fliptile","uri":"/poj-3279/"},{"categories":null,"content":"Solution If we try to brute force, with time complexity of \\(O(2^{MN})\\), we would definitely fail. Why \\(O(2^{MN})\\)? Each tile can have two states - flip or not flip, and there are total number \\(M \\times N\\) square tiles. We can see that a square tile';s color is only determined by the flip states of its adjacent tiles and its own flip state. 5 flip states =\u003e color If we know four flip states and one color, can we find out the last flip state? Sure we can! The color must be white. But which four flip state we can counter? Clearly not the four adjacent tiles around since then there is no difference from brute force. How about the upper four? Then we know the flip state of the lower tile. If we do this for the whole line, then we know the flip state of the whole line. 4 flip states + color =\u003e 1 flip state Another way to think about this is that if you know the tile’s left, upper, right and its own flip state, you can temporarily find out the color of the tile, if the color is black, then the lower tile must be flipped so that the central tile can be white. 4 flip states =\u003e color =\u003e flip? Final two questions, how should we start and check if it success after flips? To start, iterate all possibilities \\(2^N\\) of the first row. Check the color of the last row, if there is any black tile, no luck. We also need to store and maintain the minimum number of flips and the flip states of the optimal answer. Since we loop from the least lexicographical configurations, first minimum solution is the final answer, so don’t worry. Time complexity: \\(O(MN2^N)\\) ","date":"Apr 23 2018","objectID":"/poj-3279/:0:1","tags":["POJ"],"title":"POJ 3279 Fliptile","uri":"/poj-3279/"},{"categories":null,"content":"AC Code #include \u003ciostream\u003e#include \u003ccstring\u003eusing namespace std; const int INF = 0x3f3f3f3f; const int maxn = 20; // Only check its up, left, right and itself // No need to check down, 0 anyway const int dx[] = {0,-1,0,0}; const int dy[] = {0,0,1,-1}; int m, n; int p[maxn][maxn]; // original int ans[maxn][maxn]; // final answer of flip state int cur[maxn][maxn]; // current flip state int mini; int tmp; // store the current number of flips /* check the color of the tile */ int chk(int r, int c) { int sum = p[r][c]; for (int i = 0; i \u003c 4; i++) { int x = r+dx[i]; int y = c+dy[i]; if (x \u003e= 0 \u0026\u0026 x \u003c m \u0026\u0026 y \u003e=0 \u0026\u0026 y \u003c n) { sum += cur[x][y]; } } // same as sum % 2 return sum \u0026 0x1; } void solve() { // start from second row for (int i = 1; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (chk(i-1, j)) { cur[i][j] = 1; tmp++; } } } // check if success for (int i = 0; i \u003c n; i++) { if (chk(m-1, i)) { return ; } } // check minimum if (tmp \u003c mini) { mini = tmp; memcpy(ans, cur, sizeof(ans)); } } int main(void) { while (cin \u003e\u003e m \u003e\u003e n) { mini = INF; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { cin \u003e\u003e p[i][j]; } } // loop all possibilities of first row for (int i = 0; i \u003c (1 \u003c\u003c n); i++) { tmp = 0; memset(cur, 0, sizeof(cur)); // assign values to first row for(int j = 0; j \u003c n; j++) { int t = i \u003e\u003e j \u0026 0x1; cur[0][n-1-j] = t; if (t) tmp++; } solve(); } if (mini == INF) { cout \u003c\u003c \"IMPOSSIBLE\" \u003c\u003c endl; } else { for (int j = 0; j \u003c m; j++) { for (int k = 0; k \u003c n; k++) { cout \u003c\u003c ans[j][k] \u003c\u003c (k == n-1 ? \"\\n\" : \" \"); } } } } return 0; } ","date":"Apr 23 2018","objectID":"/poj-3279/:0:2","tags":["POJ"],"title":"POJ 3279 Fliptile","uri":"/poj-3279/"},{"categories":null,"content":"Sometimes we need to access Chinese content, like Youku Video, Netease Music (Cloud Music) and QQ music. It is very annoying to get “Can Only Be Streamed in Mainland China” or similar messages. Being tired of that, fortunately I have got a VPS from Aliyun and I build a proxy server using Shadowsocks on it and everything works smoothly now. ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:0","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"VPS You need to have a VPS with Chinese IP address, there are tons of choices, like Aliyun(Alibaba Cloud) and Tencent Cloud etc. ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:1","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"Install Server Then ssh to your cloud server or any other tools to get into your server and install Shadowsocks, you can follow the instruction here. I use the Python version. ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:2","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"Config Shadowsocks Config Shadowsocks, I usually write my configuration file in /etc/shadowsocks/ss.json. Please NOTE that the server attribute in most of the case should be your VPS' public IP address. However, AFAIK, for Aliyun and AWS, it will not work if you do so (Error message socket.error: [Errno 99] Cannot assign requested address will pop up when you try to run it). The reason is the public IP address is not the “actual” IP when it is used to bind IP and port to the VPS machine, it may refer to other VPS in the local network. Therefore, 0.0.0.0 to listen to all the IP addresses should be used. { \"server\":\"0.0.0.0\", \"server_port\":8080, \"local_port\":1080, \"password\":\"yourpassword\", \"timeout\":600, \"method\":\"chacha20\" } ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:3","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"Optional Install m2crypto to make encryption a little bit faster. pip install m2crypto If you want to use chacha20 as encryption method, libsodium must be installed. Otherwise, you could use aes-256-cfb. wget https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gz tar -xf libsodium-1.0.16.tar.gz \u0026\u0026 cd libsodium-1.0.16 ./configure \u0026\u0026 make -j2 \u0026\u0026 make install echo /usr/local/lib \u003e /etc/ld.so.conf.d/usr_local_lib.conf ldconfig ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:4","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"Run Run the server as daemon! ssserver -c /etc/shadowsocks/ss.json -d start Alternatively, you can run the server at the front for debugging purpose, see all the traffic going through when you connected from the client later. ssserver -c /etc/shadowsocks/ss.json ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:5","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"Install Client Finally, install clients on devices and start using it! You could install clients from here. For macOS, I recommend Shadowsocks X with Overseas mode. I prefer to use Shadowsocks client with PAC rather than using proxy for the overall system. var domains = { \"music.163.com\": 1, \"music.126.net\": 1, \"*.v.163.com\": 1, \"*.music.163.com\": 1, \"*.music.126.net\": 1, }; var proxy = \"__PROXY__\"; var direct = 'DIRECT;'; var hasOwnProperty = Object.hasOwnProperty; function FindProxyForURL(url, host) { var suffix; var pos = host.lastIndexOf('.'); pos = host.lastIndexOf('.', pos - 1); while(1) { if (pos \u003c= 0) { if (hasOwnProperty.call(domains, host)) { return proxy; } else { return direct; } } suffix = host.substring(pos + 1); if (hasOwnProperty.call(domains, suffix)) { return proxy; } pos = host.lastIndexOf('.', pos - 1); } } ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:6","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"Netease Music You need to select Using IE proxy. ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:7","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"More Information It’s only the basic setup for Shadowsocks. For advanced topics, check https://github.com/shadowsocks/shadowsocks/wiki https://shadowsocks.org/en/config/advanced.html ","date":"Mar 23 2018","objectID":"/proxy-server-cn-netease-music/:0:8","tags":["Practice"],"title":"Build a Proxy Server to Access Chinese IP Including Netease Music","uri":"/proxy-server-cn-netease-music/"},{"categories":null,"content":"A set of \\(N\\) \\((10 \\le N \\le 100)\\) lamps, numbered from 1 to N. Four types of button: Button type Usage 1 flip all lamps (On to Off, Off to On) 2 flip odd numbered lamps (e.g. 1, 3, 5) 3 flip even numbered lamps (e.g. 2, 4, 6) 4 flip \\(3k+1 ; with ; k \\ge 0\\) numbered lamps (e.g. 1, 4, 7) Given \\(C\\) (number of button presses, \\(0 \\le C \\le 10000\\)) and final state of some of the lamps, find all possible distinct configuration. At the start, all lamps are ON and \\(C = 0\\). ","date":"Aug 31 2016","objectID":"/usaco-lamps/:0:0","tags":["USACO"],"title":"USACO Party Lamps","uri":"/usaco-lamps/"},{"categories":null,"content":"Solution From the description, we can know that: Every 6 lamps is a loop, because the least common multiple of 1, 2, 3 (button 1 changes every lamps, button 2 changes one of 2 lamps and button 3 changes one of 3 lamps) is 6. If you press the same button twice, it has the same affect that if you don’t press the button. In logic symbols, \\( \\sim(\\sim p) = p \\). A button only can be switched on or off, and there are 4 types of buttons. Therefore, there are \\( 2^4 = 16 \\) possibilities. Then for \\(C = 0\\), check current state for \\(C = 1\\), press each button once for \\( C \\ge 2 \\), check every 16 possibilities. It is a good opportunity to practice bitset though. Take care that bitset does not have build-in sort supported in set :( ","date":"Aug 31 2016","objectID":"/usaco-lamps/:0:1","tags":["USACO"],"title":"USACO Party Lamps","uri":"/usaco-lamps/"},{"categories":null,"content":"Code /* ID: cepheid1 LANG: C++11 TASK: lamps */ #include\u003cfstream\u003e#include\u003calgorithm\u003e#include\u003cbitset\u003e#include\u003cvector\u003e#include\u003cmap\u003e#include\u003cset\u003e#include\u003cstring\u003eusing namespace std; ifstream fin(\"lamps.in\"); ofstream fout(\"lamps.out\"); /* convert bitset to store in map and set to get ordered */ set\u003cshort\u003e st; map\u003cshort, string\u003emp; bitset\u003c6\u003e bt; // simulates 6 lamps bitset\u003c4\u003e light; // simulates 4 buttons bool on[7], off[7]; int N, C, a; bool chk_on() { for (int i = 0; i \u003c 6 ; i++) { if (on[i] \u0026\u0026 !(bt[6-i-1])) return false; } return true; } bool chk_off() { for (int i = 0; i \u003c 6 ; i++) { if (off[i] \u0026\u0026 (bt[6-i-1])) return false; } return true; } void op(int x) { switch(x) { case 1: bt.flip(); break; case 2: for (int i = 1; i \u003c 6; i+=2) bt.flip(i); break; case 3: for (int i = 0; i \u003c 6; i+=2) bt.flip(i); break; case 4: bt.flip(2); bt.flip(5); break; default: break; } } int main(void) { fin \u003e\u003e N \u003e\u003e C; while (fin \u003e\u003e a \u0026\u0026 a != -1) { if (a%6 == 0) on[5] = true; else on[(a%6-1)] = true; } while (fin \u003e\u003e a \u0026\u0026 a != -1) { if (a%6 == 0) off[5] = true; else off[(a%6-1)] = true; } fin.close(); bt.set(); if (C == 0) { if (chk_on() \u0026\u0026 chk_off()) { if (!st.count(bt.to_ulong())) { mp[(short)bt.to_ulong()] = bt.to_string(); st.insert((short)bt.to_ulong()); } } } else if (C == 1) { for (int i = 0; i \u003c 4; i++) { bt.set(); op(i); if (chk_on() \u0026\u0026 chk_off()) { if (!st.count(bt.to_ulong())) { mp[(short)bt.to_ulong()] = bt.to_string(); st.insert((short)bt.to_ulong()); } } } } else { for (int i = 0; i \u003c 16; i++) { bt.set(); light = i; for (int j = 0; j \u003c 4; j++) { if (light[j]) op(j+1); } if (chk_on() \u0026\u0026 chk_off()) { if (!st.count(bt.to_ulong())) { mp[(short)bt.to_ulong()] = bt.to_string(); st.insert((short)bt.to_ulong()); } } } } if (st.empty()) { fout \u003c\u003c \"IMPOSSIBLE\\n\"; } else { int len = 0; string s; for (auto i : st) { len = 0; s = \"\"; while (len \u003c= N) { s += (mp[i]); len += (mp[i]).size(); } fout \u003c\u003c s.substr(0, N) \u003c\u003c endl; } } fout.close(); return 0; } ","date":"Aug 31 2016","objectID":"/usaco-lamps/:0:2","tags":["USACO"],"title":"USACO Party Lamps","uri":"/usaco-lamps/"},{"categories":null,"content":"There are one cow from each \\(N\\) (\\(1 \\le N \\le 1000\\)) farms want to go to the number X farm to have a party, hurrah! One cow from each farm need to go to the party and go back. There are \\(M\\) (\\(1 \\le M \\le 100,000\\)) weighted (represents time) one-direction roads connects pairs of roads. Cows are smart though, they want to go via the shortest path. The question is, what is the longest time the cow will take. Link: [http://poj.org/problem?id=3268] ","date":"May 14 2016","objectID":"/poj-3268/:0:0","tags":["POJ","Graph"],"title":"POJ 3268 Silver Cow Party","uri":"/poj-3268/"},{"categories":null,"content":"Solution First thought is Floyd algorithm, but look at the data for vertex N is no larger than 1000. We know the complexity of Floyd is \\(V^3\\) which is 1e9 in this case. This will definitely not work. It is easy to find out that if you consider each cow goes back to their farm after the party. It becomes that from one source what’s the shortest path to each vertex. Sounds familiar? We can use Dijkstra for this part since the complexity is \\(O(\\left|E\\right|log\\left|V\\right|\\)), worst case \\(O(\\left|E\\right|+|V|log|V|)\\). But how can we find the shortest path when each cow goes for the party? We can reverse each edge and do Dijkstra from the source X again and it will be our answer for this part. ","date":"May 14 2016","objectID":"/poj-3268/:0:1","tags":["POJ","Graph"],"title":"POJ 3268 Silver Cow Party","uri":"/poj-3268/"},{"categories":null,"content":"Code #include\u003ciostream\u003e#include\u003cqueue\u003e#include\u003calgorithm\u003e#include\u003ccstring\u003e#include\u003cfunctional\u003e#include\u003cvector\u003eusing namespace std; const int maxn = 1000+5; const int INF = 0x3f3f3f3f; typedef pair\u003cint, int\u003e P; // first: shortest path, second: vertex num; struct edge { int to, cost; }; vector\u003cedge\u003e G1[maxn]; vector\u003cedge\u003e G2[maxn]; int n, m, x; int go[maxn], back[maxn]; void dijkstra (int s, int *d, vector\u003cedge\u003e *G) { priority_queue\u003cP, vector\u003cP\u003e, greater\u003cP\u003e \u003e q; q.push(P(0, s)); while (!q.empty()) { P p = q.top(); q.pop(); int v = p.second; if (d[v] \u003c p.first) continue; for (int i = 0; i \u003c G[v].size(); i++) { edge e = G[v][i]; if (d[e.to] \u003e d[v] + e.cost) { d[e.to] = d[v] + e.cost; q.push(P(d[e.to], e.to)); } } } } int main(void) { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e x) { int u; for (int i = 1; i \u003c= n; i++) { G1[i].clear(); G2[i].clear(); } for (int i = 1; i \u003c= m; i++) { edge a; cin \u003e\u003e u \u003e\u003e a.to \u003e\u003e a.cost; G1[u].push_back(a); } fill(back, back+n+1, INF); back[x] = 0; dijkstra(x, back, G1); for (int i = 1; i \u003c= n; i++) { edge a; for (int j = 0; j \u003c G1[i].size(); j++) { a.to = i; a.cost = G1[i][j].cost; G2[G1[i][j].to].push_back(a); } } fill(go, go+n+1, INF); go[x] = 0; dijkstra(x, go, G2); int ans = -1; for (int i = 1; i \u003c= n; i++) { go[i] += back[i]; if (ans \u003c go[i]) ans = go[i]; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"May 14 2016","objectID":"/poj-3268/:0:2","tags":["POJ","Graph"],"title":"POJ 3268 Silver Cow Party","uri":"/poj-3268/"},{"categories":null,"content":"Given an array with size \\(N \\times N (N \\le 100)\\), find the maximum value of its subarray. Link: Problem on UVa ","date":"Mar 24 2016","objectID":"/uva-108/:0:0","tags":["UVa"],"title":"UVa 108 Maximum Sum","uri":"/uva-108/"},{"categories":null,"content":"Solutions First thought is to brute force - find all possible subarrays then the time complexity will be \\(O(N^6)\\). TLE for sure. Then comes up with an algorithm that takes \\(O(N^4)\\), which is enough to AC. However, it can be \\(O(N^3)\\), see solution 2. Solution 1 We build a sum array which is the sum of the numbers in rectangle area with the top-left of the array and bottom-right node \\(i, j)\\). Then as we can see at the graph below, it is obvious that $$ \\begin{align} A \u0026= (A+B+C+D)\\\\ \u0026-(B+D)\\\\ \u0026-(C+D)\\\\ \u0026+D \\end{align} $$ Therefore we have A = sum[k][l] - sum[i-1][l] - sum[j-1][k] + sum[i-1][j-1]. Go through every subarray to find the maximum. There is a trick that store the array starts with index 1 and initialize 0. So you don’t need to do boundary check. Stuck at first, could not figure out why and then found that I used \u003c instead of \u003c= in the for loop. #include\u003ciostream\u003e#include\u003calgorithm\u003e#define maxn 100+5 using namespace std; int v, N, sum[maxn][maxn] = {{0}}; void solve() { int MaxSum = -200; for (int i = 1; i \u003c= N; i++) { for (int j = 1; j \u003c= N; j++) { for (int k = i; k \u003c= N; k++) { for (int l = j; l \u003c= N; l++) { MaxSum = max(MaxSum, sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1]); } } } } cout \u003c\u003c MaxSum \u003c\u003c endl; } int main(void) { while(cin \u003e\u003e N) { for (int i = 1; i \u003c= N; i++) { for (int j = 1; j \u003c= N; j++) { cin \u003e\u003e v; sum[i][j] = v+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; } } solve(); } return 0; } Solution 2 In one dimension, if we want to find the maximum sum of successive elements, we have equation: $$ d[k] = max(d[k-1]+d[k], d[k])$$ There is a small improvement. By using greedy, we know if the sum is less than 0, there is no point to “add” it, we can just discard it. After we know how to compute in one dimension, it is easy to do it in two dimension. Let i = the starting line j = the ending line, where i \u003c= j k = the number of columns We can compress all lines between i and j into a 1D array. In other words, add each number in the same column together and put it in the 1D array. Hence, we have an array with i to j lines in it. Now, it is just the problem we have already seen. Find the maximum sum of successive elements in the 1D array. That is the sum of the whole rectangle in the original 2D array. #include\u003ciostream\u003e#include\u003ccstring\u003e#include\u003calgorithm\u003e#define maxn 100+5 using namespace std; int N, m[maxn][maxn], x[maxn]; int find_max() { int cur_sum=x[0], sum=0; for (int l = 0; l \u003c N; l++) { sum += x[l]; cur_sum = max(sum, cur_sum); if (sum \u003c 0) sum = 0; } return cur_sum; } void solve() { int MaxSum = -200; for (int i = 0; i \u003c N; i++) { memset(x, 0, sizeof(x)); for (int j = i; j \u003c N; j++) { for (int k = 0; k \u003c N; k++) x[k] += m[j][k]; MaxSum = max(MaxSum, find_max()); } } cout \u003c\u003c MaxSum \u003c\u003c endl; } int main(void) { while(cin \u003e\u003e N) { for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c N; j++) cin \u003e\u003e m[i][j]; solve(); } return 0; } ","date":"Mar 24 2016","objectID":"/uva-108/:0:1","tags":["UVa"],"title":"UVa 108 Maximum Sum","uri":"/uva-108/"},{"categories":null,"content":"Find \\(n\\)th \\( (1 \\le n \\le 5842)\\) number whose only prime factors are 2, 3, 5 or 7. Link: https://uva.onlinejudge.org/index.php?option=onlinejudge\u0026page=show_problem\u0026problem=384 ","date":"Mar 20 2016","objectID":"/uva-443/:0:0","tags":["UVa"],"title":"UVa 443 Humble Numbers","uri":"/uva-443/"},{"categories":null,"content":"Solutions Solution 1 Kind of brute force, using STL set and vector to list all humble numbers. Using long long to avoiding overflow. #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cset\u003eusing namespace std; typedef long long ll; const int t[] = { 2, 3, 5, 7}; set\u003cll\u003e s; int main(void) { s.insert(1); set\u003cll\u003e::iterator i = s.begin(); while(s.size() \u003c 6600) { for (int j = 0; j \u003c 4; j++) s.insert((*i)*t[j]); i++; } vector\u003cll\u003e v(s.begin(), s.end()); int n; string s; while (cin \u003e\u003e n) { if (n == 0) break; if (n % 100 == 11 || n % 100 == 12 || n % 100 == 13) s = \"th\"; else if (n % 10 == 1) s = \"st\"; else if (n % 10 == 2) s = \"nd\"; else if (n % 10 == 3) s = \"rd\"; else s = \"th\"; cout \u003c\u003c \"The \" \u003c\u003c n \u003c\u003c s \u003c\u003c \" humble number is \" \u003c\u003c v[n-1] \u003c\u003c \".\\n\"; } return 0; } Solution2 We have: Arrary Description a numbers of each prime factors which are used to generate humble numbers num store the 4 humble numbers and find the smallest one to fill into the ans array ans store all previous results For every humble number \\(a\\), there must exist a humble number \\(b, b \\lt a\\) so that \\(\\lbrace a = kb, k \\in \\lbrace 2, 3, 5, 7\\rbrace \\rbrace\\) #include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003cstring\u003e#define maxn 5842+5 using namespace std; const int t[] = { 2, 3, 5, 7 }; int a[4] = {1, 1, 1, 1}, num[4], n, ans[maxn]; string s; int find_min() { int Min = num[0]; for (int j = 1; j \u003c 4; j++) { if (Min \u003e num[j]) { Min = num[j]; } } return Min; } int main(void) { int index = 2; ans[1] = 1; while(index \u003c maxn) { for (int i = 0; i \u003c 4; i++) num[i] = ans[a[i]]*t[i]; ans[index] = find_min(); for (int i = 0; i \u003c 4; i++) { if (ans[index] == num[i]) a[i]++; } index++; } while (cin \u003e\u003e n) { if (n == 0) break; if (n % 100 == 11 || n % 100 == 12 || n % 100 == 13) s = \"th\"; else if (n % 10 == 1) s = \"st\"; else if (n % 10 == 2) s = \"nd\"; else if (n % 10 == 3) s = \"rd\"; else s = \"th\"; cout \u003c\u003c \"The \" \u003c\u003c n \u003c\u003c s \u003c\u003c \" humble number is \" \u003c\u003c ans[n] \u003c\u003c \".\\n\"; } return 0; } ","date":"Mar 20 2016","objectID":"/uva-443/:0:1","tags":["UVa"],"title":"UVa 443 Humble Numbers","uri":"/uva-443/"},{"categories":null,"content":"\\(N\\) (\\(1 \\le N \\le 25,000\\)) cows, each cow only available for a interval of time. \\(T\\) (\\(1 \\le T \\le 1,000,000\\)) shifts. Find minimum number of cows to complete \\(T\\) shifts. Link: http://poj.org/problem?id=2376 ","date":"Mar 16 2016","objectID":"/poj-2376/:0:0","tags":["Greedy","POJ"],"title":"POJ 2376 Cleaning Shifts","uri":"/poj-2376/"},{"categories":null,"content":"Notes Each shift must has at least one cow assigned to it. A cow finishes after the end time. That is, if there are two cows, start and end at \\((1, 3)\\) and \\((4, 10)\\) respectively. It is considered as an continuous internal and accepted case for \\(T = 10\\). There can not have any gap between these cows’s working intervals. Use scanf() for input otherwise it will run out of the time limit. ","date":"Mar 16 2016","objectID":"/poj-2376/:0:1","tags":["Greedy","POJ"],"title":"POJ 2376 Cleaning Shifts","uri":"/poj-2376/"},{"categories":null,"content":"Solution Sort cows by ending time. Using greedy that for each interval, find the cow which has latest end time and before the current end time. As the vector is sorted, the first cow we find is the answer. #include\u003ccstdio\u003e#include\u003cvector\u003e#include\u003calgorithm\u003eusing namespace std; typedef pair\u003cint, int\u003e P; vector\u003cP\u003e v; int N, T, ans = 0; struct cmp { bool operator()(const P \u0026l, const P \u0026r) { return l.second \u003e r.second; } }; void solve() { sort(v.begin(), v.end(),cmp()); int cur = 1; bool find = true; while (cur \u003c= T) { if ((v.size() == 0) || !find || (v[0].second \u003c cur)) { ans = -1; return ; } for (int i = 0; i \u003c v.size(); i++) { if (v[i].first \u003c= cur) { ans++; cur = v[i].second+1; printf(\"%d %d\\n\\n\", v[i].first, v[i].second); v.erase(v.begin()+i); find = true; break; } find = false; } } return ; } int main(void) { scanf(\"%d %d\", \u0026N, \u0026T); int start, end; for (int i = 0; i \u003c N; i++) { scanf(\"%d %d\", \u0026start, \u0026end); v.push_back(P(start, end)); } solve(); printf(\"%d\\n\", ans); return 0; } ","date":"Mar 16 2016","objectID":"/poj-2376/:0:2","tags":["Greedy","POJ"],"title":"POJ 2376 Cleaning Shifts","uri":"/poj-2376/"},{"categories":null,"content":"There is a 5 * 5 array filled with integers. You can only go up, down, left and right. You can start on any point in the array and can only move 5 times. Therefore, you will get 6 integers. Find the number of distinct integers you can constructed. Link: http://poj.org/problem?id=3050 ","date":"Mar 14 2016","objectID":"/poj-3050/:0:0","tags":["POJ"],"title":"POJ 3050 Hopscotch","uri":"/poj-3050/"},{"categories":null,"content":"Solution I use a set to avoid same sequences. Since there are only 6 steps and the array is only 5*5, dfs each point, add into the set. I used to_string() at first but got compile error on POJ, then I use stringstream but got TLE. DO NOT USE sstream, it’s just too slow! Slower than molasses! Finally, I got AC. #include\u003ciostream\u003e#include\u003cset\u003e#include\u003cstring\u003eusing namespace std; set\u003cstring\u003e ans; int m[5][5]; const int dx[] = { 1, -1, 0, 0 }; const int dy[] = { 0, 0, 1, -1 }; string s; void dfs(int x, int y, int n) { if (n == 0) { ans.insert(s); return; } for (int i = 0; i \u003c 4; i++) { int tx = x+dx[i]; int ty = y+dy[i]; if (tx \u003e= 0 \u0026\u0026 tx \u003c 5 \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c 5) { string str = s; s += m[tx][ty]; dfs(tx, ty, n-1); s = str; } } return ; } int main(void) { for (int i = 0; i \u003c 5; i++) { for (int j = 0; j \u003c 5; j++) cin \u003e\u003e m[i][j]; } for (int i = 0; i \u003c 5; i++) { for (int j = 0; j \u003c 5; j++) { s = \"\"; dfs(i, j, 6); } } cout \u003c\u003c ans.size() \u003c\u003c endl; return 0; } ","date":"Mar 14 2016","objectID":"/poj-3050/:0:1","tags":["POJ"],"title":"POJ 3050 Hopscotch","uri":"/poj-3050/"},{"categories":null,"content":"There are 1 to \\(N\\) digits (\\(1\\le N \\le 10\\)) in certain order. Add adjacent numbers together to get the next line, until the there is only one number left.(Just like Pascal’s triangle) For example, there are 3 integers: $$ 1, 2, 3 $$ $$ 3, 5 $$ $$ 8 $$ So, given \\(N\\) and the final sum, find the lexicographically least ordering of integers. Link: http://poj.org/problem?id=3187 ","date":"Mar 14 2016","objectID":"/poj-3187/:0:0","tags":["POJ"],"title":"POJ 3187 Backward Digits Sums","uri":"/poj-3187/"},{"categories":null,"content":"Notes: Be aware of that the question is asking 1 to \\(N\\) digits, so we don’t have to test all possible permutations from 1 to 10. The results of next_permutation() in STL are in ascending order in default. ","date":"Mar 14 2016","objectID":"/poj-3187/:0:1","tags":["POJ"],"title":"POJ 3187 Backward Digits Sums","uri":"/poj-3187/"},{"categories":null,"content":"Solution: Use next_permutation() to check all possibilities and stimulate the triangle additions. Since the permutation is already in lexicographical order, when we get the find the first result, it is the final answer. #include\u003ciostream\u003e#include\u003calgorithm\u003eusing namespace std; int n, sum, ans[11], s[11]; void solve() { for (int i = 1; i \u003c= n; i++) ans[i-1] = i; if (n == 1 \u0026\u0026 ans[0] == sum) { cout \u003c\u003c sum \u003c\u003c endl; return; } do { for (int i = 0; i \u003c n-1; i++) s[i] = ans[i]+ans[i+1]; for (int i = n-2; i \u003e= 0; i--) { for (int j = 0; j \u003c i; j++) s[j] = s[j]+s[j+1]; } if (s[0] == sum) { for (int i = 0; i \u003c n; i++) cout \u003c\u003c ans[i] \u003c\u003c \" \"; cout \u003c\u003c endl; return; } } while (next_permutation(ans, ans+n)); } int main(void) { cin \u003e\u003e n \u003e\u003e sum; solve(); return 0; } ","date":"Mar 14 2016","objectID":"/poj-3187/:0:2","tags":["POJ"],"title":"POJ 3187 Backward Digits Sums","uri":"/poj-3187/"},{"categories":null,"content":"Binary tree is called so because of its shape. It’s like a tree, it have leaves and a root. In computer science, the “tree” is usually upside down, the root at the top and leaves grow below it. It is binary so it every node only can have 0, 1 or 2 leaves. ","date":"Jan 15 2016","objectID":"/binary-tree/:0:0","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Terminologies ","date":"Jan 15 2016","objectID":"/binary-tree/:1:0","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Leaf Node The node do NOT have any child nodes. ","date":"Jan 15 2016","objectID":"/binary-tree/:1:1","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Inner Node The Node between the leaf node and the root. ","date":"Jan 15 2016","objectID":"/binary-tree/:1:2","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Height and Depth Height and Depth of the tree are basically the same thing which indicates how many levels the tree have, usually starts at 0. However, the height and depth of the node is different. The height and depth of a node is the distance on longest path to the leaf node and root respectively. ","date":"Jan 15 2016","objectID":"/binary-tree/:1:3","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Types ","date":"Jan 15 2016","objectID":"/binary-tree/:2:0","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Full Binary Tree Every node in the tree has either 0 or 2 children. ","date":"Jan 15 2016","objectID":"/binary-tree/:2:1","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Complete Binary Tree Every level except possibly the last level, has maximum number of nodes. All nodes in the last level are all at the left of the tree continuously. Total number of nodes \\(k\\) Height of tree \\(h\\) \\(2^h \\le k \\lt 2^{h+1} - 1\\) \\(h = \\lfloor\\log_2k\\rfloor\\) ","date":"Jan 15 2016","objectID":"/binary-tree/:2:2","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Implementation ","date":"Jan 15 2016","objectID":"/binary-tree/:3:0","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Array Array can be used to store a tree, usually in breadth-first order. It is quite good at store a complete binary tree as it will not waste spaces. The root is store at the index \\(i = 0\\), and its children are stored in \\(i = 1\\) and \\(i = 2\\). It has property that A node at \\(i\\), its children at \\(2i + 1\\) (left) and \\(2i + 2\\) (right). However, it wastes a lot of spaces when storing other trees other than complete binary trees. ","date":"Jan 15 2016","objectID":"/binary-tree/:3:1","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Struct or Class Creating nodes and connect them to their parents. struct node { int data; struct node* left; struct node* right; } ","date":"Jan 15 2016","objectID":"/binary-tree/:3:2","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Tree Traversal ","date":"Jan 15 2016","objectID":"/binary-tree/:4:0","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Depth First Search (DFS) Search the tree in the priority of depth. Using recursive calls for tree traversal is usually a good idea. Pre-order Root-Left-Right Starts from the root If left subtree has element in it, go to left. If not, go right. In-order Left-Root-Right Post-order Left-Right-Root Determine a unique tree There are only two ways to determine a unique tree given two types of traverse order. Pre-order and In-order The first element of a pre-order must be the root of the tree. Then find the same element in the In-order, we can divide the tree into two subtrees, left and right. Using the length of the left and right subtrees to find the sequences in pre-order respectively, then we can find the root element for left and right subtrees. Recursive repeat this process. In-order and Post-order Similar as above, except the root element is the last element in post-order traversal. Tips Rather than remembering the sequence, there is another way to remembering the order. Draw a continuous line, starts and ends at the root of the tree, starts from left, around the tree Try following: Pre-order: draw a dot at the left of each node In-order: draw a dot at the bottom of each node Post-order: draw a dot at the right of each node Follow the line we drew, the sequence of touching dots is the sequence of traversal. Pre-order In-order Post-order ","date":"Jan 15 2016","objectID":"/binary-tree/:4:1","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Breadth First Search (BFS) Traverse from the root to bottom, go thought each level first. ","date":"Jan 15 2016","objectID":"/binary-tree/:4:2","tags":["Data-Structure"],"title":"Binary Tree","uri":"/binary-tree/"},{"categories":null,"content":"Stack, queue and Linked lists are basic data structures. They appear in our daily life. For example, stacks of intermodal containers at the port, waiting in line(queue) to ride a roller coaster and the film The Human Centipede，if you know it. ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:0:0","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Stack ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:1:0","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Intro Stack is like a stack of intermodal containers, or a stack of book. Every time you want to put a new item, you put above the original stack, not between or below. Every time you want to remove a item, you need to start from the top, remove the item which is latest added. Hence, there is a principle called “LIFO”, Last In, First Out. Common operations: push pop ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:1:1","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Array Implementation Usually we use the first item in the array array[0] as the bottom of the stack, create index max-index to store the index of the top item, in other words, the index of the last item in the stack. Push: max_index += 1, and at the index of max_index add the item Pop: delete the item at the index max_index, max_index -= 1 ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:1:2","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Linked List Implementation Using singly linked list, use head to store the bottom of the stack, each item has next pointing at the next item. The top item’s next points to NULL, size stores the size of the stack (the length of the linked list). push: change the next variable of the top item in stack(last item in list) to the new item, let next of the new item points to NULL, size += 1 pop: delete the top item in stack (last item in list), size -= 1, set next of the new last item to NULL ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:1:3","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"C++ STL - stack #include\u003ciostream\u003e#include\u003cstack\u003eusing namespace std; int main(void) { /* create a stack named stk and its elements are int type */ stack \u003cint\u003e stk; /* push an element to the stack */ stk.push(1); // 1 stk.push(2); // 1 2 /* * cout \u003c\u003c stk.push(3) \u003c\u003c endl; * error!! stk.push(3) returns void */ /* top() returns the top element in the stack and it does NOT change the stack */ cout \u003c\u003c stk.top() \u003c\u003c endl; // print out 2 stk.push(1); /* gives the size of the stack - how many elements are there */ cout \u003c\u003c stk.size() \u003c\u003c endl; // print out 3 /* pop the top element from the stack, return void as well */ stk.pop(); stk.pop(); cout \u003c\u003c stk.top() \u003c\u003c endl; // print out 1 /* check if the stack is empty, if it is empty, returns true(1) */ cout \u003c\u003c stk.empty() \u003c\u003c endl; return 0; } ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:1:4","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Queue ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:2:0","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Intro Queue is like the queue in our life, wait in line to check out. Each new item add to the end of a queue, and the item at the front goes out first. Hence, Queue has the principle of “FIFO” (First In, First Out). Common operations: enqueue dequeue ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:2:1","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Linked List Implementation Using singly linked list, use head to track the head of a queue, each item has a variable next pointing to the next item, next of the last item in the queue points to NULL, size tracks the length of the queue. Enqueue: append the new item at the end of the queue/list, next of the old last item points to the new item just appended, size += 1 Dequeue: Using next to navigate to the second item, head points to the second item, delete the first item, size -= 1 ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:2:2","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"C++ STL - queue Almost the same as stack! Info queue uses front and back to get the first and last item respectively. #include\u003ciostream\u003e#include\u003cqueue\u003eusing namespace std; int main() { queue\u003cint\u003e q; q.push(1); // q: 1 q.push(2); // q: 1 2 cout \u003c\u003c q.front() \u003c\u003c endl; // 1 cout \u003c\u003c q.back() \u003c\u003c endl; // 2 q.push(3); // q: 1 2 3 cout \u003c\u003c q.size() \u003c\u003c endl; // 3 q.pop(); // q: 2 3 cout \u003c\u003c q.front() \u003c\u003c endl; // 2 cout \u003c\u003c q.back() \u003c\u003c endl; // 3 cout \u003c\u003c q.empty() \u003c\u003c endl; // 0 return 0; } ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:2:3","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Priority Queue Priority Queue is similar as queue, however each item has a priority. The first item to be dequeued maybe not the most front of the queue, it is now which the item has the highest priority. It’s like someone who have VIP cards, or someone is a queue-jumper, not fair for these items waiting, right? sigh. In C++ STL, if you use int as items in a priority queue, it is default that the smaller the integer is, the less priority it has. If you want the opposite, which is larger integer, less priority, you could use great\u003cint\u003e, fully declarationstd::priority_queue\u003cint, std::vector\u003cint\u003e, std::greater\u003cint\u003e q_name. If you want other custom compare methods, you might need to custom cmp function to complete priority comparison. Warning Priority Queue uses front() to get the first item, NOT top(). ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:2:4","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Linked List ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:3:0","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Intro Linked list is like linked paper clips, have you tired before? Linked list have several structures: singly linked list, doubly linked list, multiply linked list and others. We only show singly linked list here as others can be implemented with the understanding of singly linked list. Common operations: add nodes delete nodes next node ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:3:1","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"C++ Struct Implementation #include\u003ciostream\u003e struct Node { int value; Node *next; }; int main() { Node *root; Node *cur; /* Initialize the linked list */ root = new Node; root-\u003evalue = 1; root-\u003enext = NULL; cur = root; /* add Node at the end of the list */ cur = cur-\u003enext; cur = new Node; cur-\u003evalue = 2; cur-\u003enext = NULL; // linked list: 1 2 /* add Node between two Nodes */ Node *second = new Node; second-\u003evalue = 3; second-\u003enext = cur; root-\u003enext = second; // linked list: 1 3 2 /* known value, find Node */ cur = root; while (cur-\u003evalue != 3) { cur = cur-\u003enext; } std::cout \u003c\u003c cur-\u003evalue \u003c\u003c std::endl; // 3 /* traverse to the last Node */ while (cur-\u003enext != NULL) { cur = cur-\u003enext; } std::cout \u003c\u003c cur-\u003evalue \u003c\u003c std::endl; // 2 /* delete Node */ Node *last; cur = root; if (cur == NULL) ; // empty list if (cur-\u003evalue == 1) { // if we want to delete the first node root = cur-\u003enext; delete cur; } else { while (cur-\u003evalue != 1 \u0026\u0026 cur-\u003enext != NULL) { last = cur; cur = cur-\u003enext; } if (cur-\u003evalue == 1) { last-\u003enext = cur-\u003enext; delete cur; } } } ","date":"Dec 25 2015","objectID":"/stack-queue-linked-list/:3:2","tags":["Data-Structure"],"title":"Stack, Queue and Linked Lists","uri":"/stack-queue-linked-list/"},{"categories":null,"content":"Why Jekyll and Github Pages Jekyll is an static site generator, it is simple to use with YAML front matter. It is quite convenient to blog with markdown and Jekyll supports it build-in. Github Pages provide the space to host the website for free. Both of them are well-documented, and works well with each other. One thing that makes they works well but not perfect is that although Github Pages can generate the website using Jekyll but as it generates in safe mode, it does not support Jekyll plugin. However, the good news is we can generate the site locally and then push it to Github. It sounds like not convenient but we can write a bash script to do so automatically in one step. We will talk about it later. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:1:0","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Preparations Know YAML front matter is something you can put at the front of a script and it can automatically have part of the layout and tags you defined before define variables (Liquid) If you don’t know HMTL, CSS or JavaScript, you would better check out W3School and at least know the basic of them. Be able to using git commands, if not please check Git tutorial or search on Google. You could use a desktop version instead of command lines, but I think it’s better to try comment line once because it may help you to have a better understanding of how it works. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:2:0","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Set up repository Following the steps on Github Pages to initiate the repository. Caution: If you are building user/organisation pages, please use master branch, if you are building project pages, please use gh-pages instead. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:3:0","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Install and Initiate Steps are shown here. After installation, to initiate a basic theme Jekyll website at current folder, simply run Jekyll new . git init If you have a error says the directory is not empty, just move all files to other directory and move them back after initiation. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:4:0","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Running Jekyll and Test Websites Locally If you use bundler, you need to use bundle exec jekyll server or bundle exec jekyll serve. For those who don’t, please use jekyll server or jekyll serve. Leave command window as it is running and then open your browser and navigate to http://localhost:4000 and you can see your site locally. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:5:0","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Configuring ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:6:0","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"_config.yml file _config.yml contains settings for the website, check out details at the official website here. Variables Usage title The title of the website, by default it will shown at the website and the search result in a search engine email It is used in the contact list if you choose to use it description By default it is used in the meta tag in the head and shown in the footer baseurl the subpath of your site, e.g. /blog will have www.pwzxxm./com/blog url the base hostname and protocol for the site, e.g. http://www.pwzxxm.com github_username twitter_username shown in the contact list in the footer if you wish markdown which markdown engine you want to use, e.g. kramdown redcarpet highlighter which syntax highlighter you want to use, e.g. pygments rouge permalink set to pretty will have url like site_url/time/title you can set your own like /:title/ See details pagination the number of posts you want to display on each page ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:6:1","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Host your website using custom domain you need to buy a domain from a domain registrar, like Godaddy. add a CNAME file which contains your custom domain name in the root of your repository. If your custom domain is a subdomain (like www.pwzxxm.com or blog.pwzxxm.com), then you need to add a CNAME record in your domain provider or DNS server provider if you are using custom DNS service. If your domain is an apex domain (only have one dot in your custom domain), you need to set up A, ALIAS or ANAME records. Add 192.30.252.153 and 192.30.252.154 to your records. Find more details ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:6:2","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Pagination There are two basic scripts can do pagination on Jekyll official documentation. However, I found this pagination from Timble which is awesome. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:6:3","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Multi-language site Check out Jekyll Multi Language Plugin. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:6:4","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"Build the site locally if you use plugins The problem is Github build Jekyll websites in safe mode so the plugin won’t work. However, we can create a ‘dummy’ repository to generate the site first and then move the content in _site folder to the original repository. generate the site locally using bundle exec jekyll serve build or jekyll build in the ‘dummy’ repository. copy all files to the actual repository excludes README.md. cut the files under _site folders to the root path of the repository. touch .nojekyll to disable github to generate the site commit all changes. Here is a bash script: #!/bin/bash comment=\"$1\" push_commit=\"git commit -a -m '$comment'\" # commit and push changes eval 'cd ~/git/local' # modify PATH here eval 'bundle exec jekyll build' eval 'git add .' eval $push_commit eval 'git push --all origin' # copy remove in pwzxxm.github.io eval 'cd ~/git/PwzXxm.github.io' # modify PATH here eval 'cp ./README.md ~/git/' # modify where you want to temporally put the README.md eval 'rm -rf ./*' eval 'cp -r ~/git/local/* ./' # modify PATH here eval 'cp -r _site/* ./' eval 'rm -rf _site/*' eval 'cp ~/git/README.md ./' # put the file back eval 'touch .nojekyll' # commit and push changes eval 'git add .' eval $push_commit eval 'git push --all origin' echo \"Done\" To use it, simply copy it to a yourchoice.sh file, change the paths in the file and give it permission to run, and run it. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:6:5","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"This Site If you like the style or you want to know the codes behind it, just check out: Pwzxxm.github.io local site You can grab and use any code from my site as you wish. However, the content of this site is copyright, if you want to use any posts please contact me. ","date":"Dec 15 2015","objectID":"/building-blog-jekyll/:7:0","tags":["Blog","Practice"],"title":"Using Jekyll + Github Pages to build a blog","uri":"/building-blog-jekyll/"},{"categories":null,"content":"PwzXxm is my first blog and also my first website I have ever built. I knew only a little bit of HTML before I started this project. I learned CSS and JavaScript while I’m building the site. I also read a lot of source code and blog posts about how other people build their own site using Jekyll. It took me seven days. Finally, on the 10th of December, 2015, the site went alive. Details about building the site, [click me]({{ site.baseurl }}/2015/building-blog-jekyll/). I was learning algorithms, c++ and practice ACM-ICPC but I stuck at graph theory and I did not have any progress on one particular problem for like three or four days. I always want to build a website and start writing some stuff. So I put other things aside and started to build this blog, and my friends give a lot of suggestions on the design of the website. Thank you. There are two reasons why I really want to start this blog. One is that blogging helps me clear my thoughts. For instance, if you can teach an algorithm to a man which is new to him and he can understand the algorithm very well as your explanation is clear, you should also already have a deep understanding on this algorithm. So another reason is that I’m hoping someone can learn something from my blog. There a story: one day, I was trying to learn KMP (a string search algorithm), I barely understand it. I read a lot of posts from other people’s blog, watched youtube videos and tried to do it on a paper. Suddenly, I knew the concept behind it. Thanks for the guys sharing their ideas and thinkings. If anyone find any mistake on my blog, please feel free to contact me or leave a comment below the post. Contact details are shown on the footer on every pages of the blog. Let’s learn together and share ideas! ","date":"Dec 12 2015","objectID":"/the-story-about-the-blog/:0:0","tags":["Blog"],"title":"The Story About the Blog","uri":"/the-story-about-the-blog/"}]