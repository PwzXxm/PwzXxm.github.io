[{"categories":null,"content":"力扣挑战第二周。因为有事，所以参加了模拟比赛。 ","date":"Oct 2 2019","objectID":"/zh-cn/lc-week-2/:0:0","tags":["LeetCode"],"title":"力扣周赛 156 + 其他题目","uri":"/zh-cn/lc-week-2/"},{"categories":null,"content":"Weekly Contest 156 ","date":"Oct 2 2019","objectID":"/zh-cn/lc-week-2/:1:0","tags":["LeetCode"],"title":"力扣周赛 156 + 其他题目","uri":"/zh-cn/lc-week-2/"},{"categories":null,"content":"1207. Unique Number of Occurrences https://leetcode.com/contest/weekly-contest-156/problems/unique-number-of-occurrences/ 暴力。记下每个数出现的次数，遍历次数看有没有相同的。 class Solution { public: bool uniqueOccurrences(vector\u003cint\u003e\u0026 arr) { unordered_map\u003cint, int\u003e occ; unordered_map\u003cint, bool\u003e flag; for (int i = 0; i \u003c arr.size(); ++i) { occ[arr[i]]++; } for (const auto x : occ) { if (flag.find(x.second) != flag.end()) { if (flag[x.second]) return false; } else { flag[x.second] = true; } } return true; } }; ","date":"Oct 2 2019","objectID":"/zh-cn/lc-week-2/:1:1","tags":["LeetCode"],"title":"力扣周赛 156 + 其他题目","uri":"/zh-cn/lc-week-2/"},{"categories":null,"content":"1208. Get Equal Substrings Within Budget https://leetcode.com/contest/weekly-contest-156/problems/get-equal-substrings-within-budget/ 两个指针分别记录当前子字符串的起点和终点。可以这样想：在一开始，我们看更换下一个字符的操作花费是否大于maxCost，如果小于或等于，终点指针就向后移一位。重复这个操作直到操作失败。 然后如果我们想再加入下一个字符，因为我们的total_cost已经“满了”，就必须从开头省出一个操作的花费：减去更换开头字符的操作并往右移动一位起点指针。 class Solution { public: int equalSubstring(string s, string t, int maxCost) { int maxi = -1; int total_cost = 0; int l = 0, r = 0; while (r \u003c t.size()) { int c = abs(s[r]-t[r]); while ((total_cost + c) \u003c= maxCost) { total_cost += c; r++; if (r \u003e= s.size()) break; c = abs(s[r]-t[r]); } maxi = max(maxi, r-l); total_cost -= abs(s[l] - t[l]); l++; } return maxi; } }; ","date":"Oct 2 2019","objectID":"/zh-cn/lc-week-2/:1:2","tags":["LeetCode"],"title":"力扣周赛 156 + 其他题目","uri":"/zh-cn/lc-week-2/"},{"categories":null,"content":"1209. Remove All Adjacent Duplicates in String II https://leetcode.com/contest/weekly-contest-156/problems/remove-all-adjacent-duplicates-in-string-ii/ 栈。每次我们碰到一个新的字符，就往栈顶加入这个字符和一个初始为1的计数器。如果下一个字符和栈顶的字符相同，就增加计数器的计数。当计数和k相同时，把该字符从栈中扔掉。 class Solution { public: string removeDuplicates(string s, int k) { int s_size = s.size(); if (s_size \u003c= 1) return s; string ans; stack\u003cpair\u003cchar, int\u003e \u003e stk; stk.push({s[0], 1}); for (int i = 1; i \u003c s_size; i++) { if (!stk.empty() \u0026\u0026 stk.top().first == s[i]) { stk.top().second++; if (stk.top().second == k) { stk.pop(); } } else { stk.push({s[i], 1}); } } while (!stk.empty()) { pair\u003cchar, int\u003e p = stk.top(); stk.pop(); ans += string(p.second, p.first); } reverse(ans.begin(), ans.end()); return ans; } }; ","date":"Oct 2 2019","objectID":"/zh-cn/lc-week-2/:1:3","tags":["LeetCode"],"title":"力扣周赛 156 + 其他题目","uri":"/zh-cn/lc-week-2/"},{"categories":null,"content":"1210. Minimum Moves to Reach Target with Rotations https://leetcode.com/contest/weekly-contest-156/problems/minimum-moves-to-reach-target-with-rotations/ 广度遍历搜索。这题不难只要把实现写对了就行。 class Solution { typedef pair\u003cint, int\u003e block_t; typedef pair\u003cblock_t, block_t\u003e block2_t; typedef pair\u003cblock2_t, int\u003e state_t; // step public: int minimumMoves(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) { int N = grid.size(); queue\u003cstate_t\u003e q; q.push({{{0, 0}, {0, 1}}, 0}); set\u003cblock2_t\u003e visited; visited.insert({{0, 0}, {0, 1}}); pair\u003cset\u003cblock2_t\u003e::iterator, bool\u003e rst; while (!q.empty()) { state_t s = q.front(); q.pop(); block_t a = s.first.first; block_t b = s.first.second; int step = s.second; if (a.first == b.first) { // horizontal if (a.first == N-1 \u0026\u0026 a.second == N-2 \u0026\u0026 b.first == N-1 \u0026\u0026 b.second == N-1) { return step; } if (b.second+1 \u003c N \u0026\u0026 grid[b.first][b.second+1] == 0){ // right rst = visited.insert({{b.first, b.second}, {b.first, b.second+1}}); if (rst.second) { q.push({{{b.first, b.second}, {b.first, b.second+1}}, step+1}); } } if (a.first+1 \u003c N \u0026\u0026 grid[a.first+1][a.second] == 0 \u0026\u0026 grid[b.first+1][b.second] == 0) { // down rst = visited.insert({{a.first+1, a.second}, {b.first+1, b.second}}); if (rst.second) { q.push({{{a.first+1, a.second}, {b.first+1, b.second}}, step+1}); } // clockwise rst = visited.insert({{a.first, a.second}, {a.first+1, a.second}}); if (rst.second) { q.push({{{a.first, a.second}, {a.first+1, a.second}}, step+1}); } } } else { // vertical if (b.first+1 \u003c N \u0026\u0026 grid[b.first+1][b.second] == 0){ // down rst = visited.insert({{b.first, b.second}, {b.first+1, b.second}}); if (rst.second) { q.push({{{b.first, b.second}, {b.first+1, b.second}}, step+1}); } } if (a.second+1 \u003c N \u0026\u0026 grid[a.first][a.second+1] == 0 \u0026\u0026 grid[b.first][b.second+1] == 0) { // right rst = visited.insert({{a.first, a.second+1}, {b.first, b.second+1}}); if (rst.second) { q.push({{{a.first, a.second+1}, {b.first, b.second+1}}, step+1}); } // anti-clockwise rst = visited.insert({{a.first, a.second}, {a.first, a.second+1}}); if (rst.second) { q.push({{{a.first, a.second}, {a.first, a.second+1}}, step+1}); } } } } return -1; } }; ","date":"Oct 2 2019","objectID":"/zh-cn/lc-week-2/:1:4","tags":["LeetCode"],"title":"力扣周赛 156 + 其他题目","uri":"/zh-cn/lc-week-2/"},{"categories":null,"content":"这是力扣第一周挑战，包括周赛 155 和其他一些题目。 ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:0:0","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"Weekly Contest 155 https://leetcode.com/contest/weekly-contest-155 ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:1:0","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"1200. Minimum Absolute Difference https://leetcode.com/contest/weekly-contest-155/problems/minimum-absolute-difference/ 暴力。先遍历找到最小绝对差，接着再遍历一遍输出差值是该值的整数对。 class Solution { public: vector\u003cvector\u003cint\u003e\u003e minimumAbsDifference(vector\u003cint\u003e\u0026 arr) { vector\u003cvector\u003cint\u003e\u003e ans; if (arr.size() == 1) return ans; sort(arr.begin(), arr.end()); int mini = 0x3f3f3f3f; for (int i = 1; i \u003c arr.size(); ++i) { mini = min(mini, abs(arr[i] - arr[i-1])); } for (int i = 1; i \u003c arr.size(); ++i) { if (abs(arr[i]- arr[i-1]) == mini) { if (arr[i] \u003c arr[i-1]) { ans.push_back({arr[i], arr[i-1]}); } else { ans.push_back({arr[i-1], arr[i]}); } } } return ans; } }; ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:1:1","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"1201. Ugly Number III https://leetcode.com/contest/weekly-contest-155/problems/ugly-number-iii/ 二分 + 容斥。能被A或B整除的数的个数等于能被A整除的数的个数加上能被B整除的数的个数，减去能被A，B同时整除的数的个数。相同的理论也可以用于三个数。 这题n的范围是 $[1, 2 \\cdot 10^9]$，二分的时间复杂度为 $\\log_2(2 \\cdot 10^9)$，所以是可行的。 typedef long long LL; class Solution { LL gcd(LL x, LL y) { return (y == 0 ? x : gcd(y, x % y)); } LL lcm(LL x, LL y) { return x / gcd(x, y) * y; } public: LL nthUglyNumber(LL n, LL a, LL b, LL c) { LL l = 1, r = 2e9, mid, cnt; LL lcm_ab = lcm(a, b); LL lcm_ac = lcm(a, c); LL lcm_bc = lcm(b, c); LL lcm_abc = lcm(lcm_ab, c); while (l \u003c r) { mid = (l+r)/2; cnt = mid/a + mid/b + mid/c - mid/lcm_ab - mid/lcm_ac - mid/lcm_bc + mid/lcm_abc; if (cnt \u003c n) { l = mid+1; } else { r = mid; } } return l; } }; ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:1:2","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"1202. Smallest String With Swaps https://leetcode.com/contest/weekly-contest-155/problems/smallest-string-with-swaps/ 并查集。我们可以看出如果在(1,2)，(2,5)上的元素分别可以被交换，那它们三个元素可以被任意交换，组成任意排列。 所以我们可以先把能互相交换的元素用并查集捆绑起来，最后构造答案时优先选用各个组里字典序最小的。 class Solution { const static int MAXN = 1e5+5; int par[MAXN]; int rk[MAXN]; int find(int x) { return (par[x] == x ? x : par[x] = find(par[x])); } void unite(int x, int y) { x = find(x); y = find(y); if (x == y) return ; if (rk[x] \u003c rk[y]) { par[x] = y; } else { par[y] = x; if (rk[x] == rk[y]) rk[x]++; } } public: string smallestStringWithSwaps(string s, vector\u003cvector\u003cint\u003e\u003e\u0026 pairs) { int n = s.size(); for (int i = 0; i \u003c n; ++i) { par[i] = i; rk[i] = 0; } for (int i = 0; i \u003c pairs.size(); ++i) { unite(pairs[i][0], pairs[i][1]); } string ans; unordered_map\u003cint, string\u003e m; for (int i = 0; i \u003c n; ++i) { m[find(i)].push_back(s[i]); } for (auto \u0026x : m) { sort(x.second.begin(), x.second.end()); } for (int i = 0; i \u003c n; ++i) { ans += m[find(i)][0]; m[find(i)].erase(0, 1); } return ans; } }; ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:1:3","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"1203. Sort Items by Groups Respecting Dependencies https://leetcode.com/contest/weekly-contest-155/problems/sort-items-by-groups-respecting-dependencies/ 拓扑排序两次。 首先，我们给那些单独成一组的元素进行编号（原先为-1）。 然后我们对于各个组进行拓扑排序。我们只关心组之间的边，忽略组内的边。 最后再循环各个组，对每个组进行一次拓扑排序，输出结果。 class Solution { public: vector\u003cint\u003e sortItems(int n, int m, vector\u003cint\u003e\u0026 group, vector\u003cvector\u003cint\u003e\u003e\u0026 beforeItems) { // independent element belongs to its own group for (int i = 0; i \u003c group.size(); ++i) { if (group[i] \u003c 0) group[i] = m++; } vector\u003cvector\u003cint\u003e \u003e group_edge(m), within_group_edge(n); vector\u003cint\u003e group_deg(m), within_group_deg(n); for (int i = 0; i \u003c n; ++i) { for (const auto\u0026 y : beforeItems[i]) { if (group[i] == group[y]) { within_group_edge[y].push_back(i); within_group_deg[i]++; } else { group_edge[group[y]].push_back(group[i]); group_deg[group[i]]++; } } } // topo sort groups vector\u003cint\u003e topo; queue\u003cint\u003e q; for (int i = 0; i \u003c m; ++i) { if (group_deg[i] == 0) q.push(i); } while (!q.empty()) { int u = q.front(); q.pop(); for (const auto\u0026 v : group_edge[u]) { group_deg[v]--; if (group_deg[v] == 0) { q.push(v); } } topo.push_back(u); } if (topo.size() != m) return {}; // topo sort within each group vector\u003cint\u003e ans; vector\u003cvector\u003cint\u003e \u003e group_member(m); for (int i = 0; i \u003c n; ++i) { group_member[group[i]].push_back(i); } for (const auto\u0026 g : topo) { queue\u003cint\u003e q2; vector\u003cint\u003e topo2; for (const auto\u0026 x : group_member[g]) { if (within_group_deg[x] == 0) q2.push(x); } while (!q2.empty()) { int u = q2.front(); q2.pop(); for (const auto\u0026 v : within_group_edge[u]) { within_group_deg[v]--; if (within_group_deg[v] == 0) { q2.push(v); } } topo2.push_back(u); } if (topo2.size() != group_member[g].size()) return {}; for (const auto\u0026 x : topo2) { ans.push_back(x); } } return ans; } }; ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:2:0","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"LeetCode 8 - String to Integer (atoi) https://leetcode.com/problems/string-to-integer-atoi/ 这题有点奇怪。像+-123这样的数据没有在题目解释中说明。 需要注意的是检查溢出的条件。注意int的最后一位是7。 ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:3:0","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"Solution class Solution { public: int myAtoi(string str) { int sign = 1; int ans = 0; int i = 0; while (isspace(str[i])) ++i; if (str[i] == '+' || str[i] == '-') { sign = (str[i++] == '+' ? 1 : -1); } for (; i \u003c str.size(); ++i) { if (str[i] \u003e= '0' \u0026\u0026 str[i] \u003c= '9') { if (ans \u003e INT_MAX/10 || (ans == INT_MAX/10 \u0026\u0026 str[i] \u003e '7')) { return (sign==1 ? INT_MAX : INT_MIN); } ans *= 10; ans += (str[i]-'0'); } else { break; } } return sign*ans; } }; ","date":"Sep 19 2019","objectID":"/zh-cn/lc-week-1/:3:1","tags":["LeetCode"],"title":"力扣周赛 155 + 其他题目","uri":"/zh-cn/lc-week-1/"},{"categories":null,"content":"CLDictP是一个用Perl，韦氏词典API写的命令行英文词典工具。 这是我第一个用Perl写的小项目。每次想用Quizlet做Flashcard（抽认卡？）来记单词的时候，因为想有的地方要加粗之类的，手动很麻烦。而且查单词的时候打开在线词典，太懒了，就想着写一个小工具吧。 它使用了如下韦氏词典API: 韦氏学习词典 韦氏大学词典 每个词条包括: 音标 词性 语法 释义 常用用法 例句 所有搜索过的单词存在一个集合里，保存在searched.txt里。 新的搜索结果会使用特定格式被保存在quizlet.txt里： 单词和定义之间：$ 卡片与卡片之间：--- ","date":"Jul 4 2018","objectID":"/zh-cn/cldictp/:0:0","tags":["Perl"],"title":"CLDictP: 命令行英文词典工具","uri":"/zh-cn/cldictp/"},{"categories":null,"content":"用法 获得API密匙：DictionaryAPI 在api_template.json中加入获得的密匙，更改文件名为api.json 安装依赖模块： $ cpan Term::ANSIColor Term::ReadKey LWP::UserAgent LWP::Protocol::https Readonly XML::LibXML JSON::XS Data::Dumper Set::Light 运行脚本： $ perl dict.pl 使用Ctrl+D退出 ","date":"Jul 4 2018","objectID":"/zh-cn/cldictp/:1:0","tags":["Perl"],"title":"CLDictP: 命令行英文词典工具","uri":"/zh-cn/cldictp/"},{"categories":null,"content":"演示 ","date":"Jul 4 2018","objectID":"/zh-cn/cldictp/:2:0","tags":["Perl"],"title":"CLDictP: 命令行英文词典工具","uri":"/zh-cn/cldictp/"},{"categories":null,"content":"源码 源码在Github ","date":"Jul 4 2018","objectID":"/zh-cn/cldictp/:3:0","tags":["Perl"],"title":"CLDictP: 命令行英文词典工具","uri":"/zh-cn/cldictp/"},{"categories":null,"content":"静态链表是一种用数组静态储存的数据结构。它通常用来表示图。它还有个非常有趣的名字叫“链式前向星”。你可以通过以下两种方式来了解它： 从前向星开始. 从领接表开始. 但是我还是建议两种都了解一下啦。如果你知道其中一种或两种的吧，点这里跳过。点一下，玩一年。 在本文中，让u表示边从该节点出发，v表示边到达该节点。 ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:0:0","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"前向星 前向星也叫做领接数组，边集数组。我们先把所有的边按照出发节点排序，到达节点的顺序不重要。接着分别用两个数组，一个存节点的在边数组的下标，一个存改节点的出度（有多少条边从该节点出发）。 ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:1:0","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"范例 我们的图包含如下这些边（出，入）： (1, 2) (2, 4) (3, 4) (1, 3) (4, 3) (3, 2) (1, 4) 我们首先以出发节点进行排序然后填入数组： es[]: 所有的到达节点 head[]: 以u为起点的第一条边的位置 len[]: u的出度（从该节点出发的边的数量） (1, 2) --| (1, 3) --| =\u003e len[1] = 3 (1, 4) --| (2, 4) (3, 2) =\u003e head[3] = 5 (3, 4) (4, 3) ^ es[] Array 1 2 3 4 5 6 7 es 2 3 4 4 2 4 3 head 1 4 5 7 len 3 1 2 1 下面我们来看如何取得所有从节点1出发的所有边。我们可以用head[1] == 1来找到第一条边在es[]中的位置是1。然后从head[1]到head[1]+len[1]遍历es[]，得到es[1+0] == 2, es[1+1] == 3, es[1+2] == 4。这样我们就得到了边(1,2), (1,3), (1,4)。 // 找到所有从u出发的边 for (int i = 0; i \u003c len[u]; i++) { cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c es[head[u]+i] \u003c\u003c endl; } 因为前向星需要进行一次排序操作，时间复杂度提升到了$ O(E \\times log(E)) $， 所以前向星并不是非常常用。然而链式前向星避免了排序，就解决了这个问题。 ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:1:1","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"领接表 领接表在C++中通常用vector\u003cint\u003e G[MAXN_V]来实现。G[u]指向一个包含所有从u出发的边的vector。 ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:2:0","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"范例 最后的结果如下图所示，左边的数组表示G[]。当我们读入一条从u出发的边，就推入G[u]的vector. for (int i = 0; i \u003c G[u].size(); i++) { cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c G[u][i] \u003c\u003c endl; } ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:2:1","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"链式前向星 链式前向星是前向星的改进版本，也可以说是领接表的静态版本。它不用像前向星那样进行排序。它是怎么做到的？不停地戳自己！：） ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:3:0","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"范例 我们和上文使用相同的范例。 有如下边（出发，到达）： (1, 2) (2, 4) (3, 4) (1, 3) (4, 3) (3, 2) (1, 4) ^ es[] 我们开始构造数组： es[]: 所有的到达节点v，出发节点的信息会在head[]中储存。 head[]: 以u为起点的第一条边的位置。 next[]: 下一条以u为起点的边在es[]中的位置。用0来代表已经是最后一条了。 可以得到 Array 1 2 3 4 5 6 7 es 2 4 4 3 3 2 4 head 1 2 3 5 next 4 0 6 7 0 0 0 我们需要另一个数组储存每个节点最后一条边的位置来构造next[]数组。当然我们也可以反向构造，不断更新head[]来储存。 下面我们来看如何得到从节点1出发的所有边： 用head[1] == 1来找到第一条边的位置，设i = head[1]，es[i] == 2输出了(1, 2)这条边，更新 i = next[i]，现在i == 4。 es[i] == 3 输出边(1, 3)，更新i = next[i]，现在i == 7。 es[i] == 4 输出边(1, 4)，更新i = next[i], 现在i == 0。 因为i == 0，结束。 for (int i = head[u]; i; i = next[i]) { cout \u003c\u003c u \u003c\u003c \" \" \u003c\u003c es[i] \u003c\u003c endl; } 发现了吗？链式前向星除了第一次使用head[]，其他时候都在es[]和next[]之间左右横跳来得到下一数据。想法和链表很像，不过用的是数组实现的。 ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:3:1","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"比较 前向星$O(E \\times log(E))$的复杂度让人望而却步，有时候可能会变得更糟。 领接表易于理解，用C++ STL vector也易于实践。vector动态分配空间所以我们不用知道边的数量。但是，有时候可能会浪费空间因为vector在需要的时候会加倍分配空间。 链式前向星不改变数组的顺序，它只是建立起了边之间的关系。它比使用STL更快而且在理解之后易于实现。 但是，这些数据结构都在寻找一条特定的边的时候不太优秀，在最坏情况下需要遍历到链表结束。 ","date":"May 29 2018","objectID":"/zh-cn/static-linked-list/:4:0","tags":["Graph","Data-Structure"],"title":"静态链表（链式前向星）- 表示图的另一种方法","uri":"/zh-cn/static-linked-list/"},{"categories":null,"content":"遥远的那边有\\(M \\times N\\) \\((1 \\le M, N \\le 15)\\)块瓷砖。每块瓷砖都能被翻转，它的两面分别是白色（0）和黑色（1）。 当你翻转一块砖的时候，相邻的四块砖也会被翻转。注意它们的翻转不会带动它们相邻的再继续翻转喔。 现在给你一种布局，输出翻转哪些瓷砖，使得所有瓷砖都变成白色，且翻转数目最小。如果有多种翻转方法但翻转数相同，输出字典序1最小的。 如果没有解，输出\"IMPOSSIBLE\"。 链接: http://poj.org/problem?id=3279 1 字典序：从左往右读，比较每个字符在字典中出现的先后顺序， 比如说：\\((AA \\lt AB \\lt BA \\lt BB \\))。在今天瓷砖的这个情境下，我们从左往右然后从上往下读 0 0 0 0 0 0 1 0 0 0 0 0 \u003c 1 1 1 \u003c 0 0 0 0 0 0 1 1 1 0 0 0 ⚠️再努力想想 ","date":"Apr 23 2018","objectID":"/zh-cn/poj-3279/:0:0","tags":["POJ"],"title":"POJ 3279 Fliptile","uri":"/zh-cn/poj-3279/"},{"categories":null,"content":"题解 暴力的时间复杂度有\\(O(2^{MN})\\)，是肯定超时的。为什么是\\(O(2^{MN})\\)？每块瓷砖有两种状态——翻或不翻，一共有\\(M \\times N\\)块瓷砖。 我们能看到一块瓷砖的颜色只取决于相邻四块瓷砖和自己的翻转状态。 5 翻转状态 =\u003e 颜色 如果我们知道了四个翻转状态和一个颜色，我们能找出最后一个翻转状态吗？显然是可以的。颜色我们肯定希望是白色。但是问题是哪四个呢？肯定不是周围四个，那样和暴力没差。 不如试试用靠上的四个？这样我们就能知道底下的瓷砖该不该翻转了。如果我们在一行上进行这个操作，整行的翻转状态都能知道了。 4 翻转状态 + 颜色 =\u003e 1 翻转状态 还可以换个方式想，如果我们知道一个瓷砖上，左，右和它自己的翻转状态，我们就能暂时知道它的颜色。如果是黑色，我们就翻转下面的瓷砖，让它变成白色。 4 翻转状态 =\u003e 颜色 =\u003e 需要翻转? 最后两个问题，我们怎么开始呢？如何知道全部翻转完成后是否成功呢？ 我们可以直接尝试第一行所有的可能性。 在最后我们可以查看最后一行的颜色。如果还有黑色，则失败。 我们还需要维护最小翻转数和那时所有的翻转状态。因为我们从最小字典序开始循环，所以第一个有着最少翻动数的解就是最小字典序的解啦！可以完全不用担心这一块。 时间复杂度：\\(O(MN2^N)\\) ","date":"Apr 23 2018","objectID":"/zh-cn/poj-3279/:0:1","tags":["POJ"],"title":"POJ 3279 Fliptile","uri":"/zh-cn/poj-3279/"},{"categories":null,"content":"AC 代码 #include \u003ciostream\u003e#include \u003ccstring\u003eusing namespace std; const int INF = 0x3f3f3f3f; const int maxn = 20; // 只用查询上，左，右和自己 // 不过反正下面也一直是0 const int dx[] = {0,-1,0,0}; const int dy[] = {0,0,1,-1}; int m, n; int p[maxn][maxn]; // 输入的布局 int ans[maxn][maxn]; // 最后的答案 int cur[maxn][maxn]; // 当前的翻转状态 int mini; int tmp; // 当前的翻转数 /* 查找颜色 */ int chk(int r, int c) { int sum = p[r][c]; for (int i = 0; i \u003c 4; i++) { int x = r+dx[i]; int y = c+dy[i]; if (x \u003e= 0 \u0026\u0026 x \u003c m \u0026\u0026 y \u003e=0 \u0026\u0026 y \u003c n) { sum += cur[x][y]; } } // 和sum % 2是一样的 return sum \u0026 0x1; } void solve() { // 从第二行开始循环 for (int i = 1; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (chk(i-1, j)) { cur[i][j] = 1; tmp++; } } } // 检查最后一行颜色 for (int i = 0; i \u003c n; i++) { if (chk(m-1, i)) { return ; } } // 是不是最小 if (tmp \u003c mini) { mini = tmp; memcpy(ans, cur, sizeof(ans)); } } int main(void) { while (cin \u003e\u003e m \u003e\u003e n) { mini = INF; for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { cin \u003e\u003e p[i][j]; } } // 遍历第一行的所有可能 for (int i = 0; i \u003c (1 \u003c\u003c n); i++) { tmp = 0; memset(cur, 0, sizeof(cur)); // 给第一行赋值 for(int j = 0; j \u003c n; j++) { int t = i \u003e\u003e j \u0026 0x1; cur[0][n-1-j] = t; if (t) tmp++; } solve(); } if (mini == INF) { cout \u003c\u003c \"IMPOSSIBLE\" \u003c\u003c endl; } else { for (int j = 0; j \u003c m; j++) { for (int k = 0; k \u003c n; k++) { cout \u003c\u003c ans[j][k] \u003c\u003c (k == n-1 ? \"\\n\" : \" \"); } } } } return 0; } ","date":"Apr 23 2018","objectID":"/zh-cn/poj-3279/:0:2","tags":["POJ"],"title":"POJ 3279 Fliptile","uri":"/zh-cn/poj-3279/"},{"categories":null,"content":"身在国外，我们有时候需要看看优酷，听听网易云音乐、QQ音乐。看到“仅限中国大陆播放”的时候真的好气啊。公用的代理服务器我又有点强迫症，正好手头上有个阿里云的服务器，就用Shadowsocks搭建了一个，现在可以开心地听歌啦。 ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:0","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"VPS 你需要一个有中国公网IP地址地服务器。国内服务器有很多选择，比如阿里云，腾讯云，美团云之类的。 ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:1","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"安装服务器端 用ssh或者其他工具进入服务器，然后安装Shadowsocks。关于安装的步骤，可以看这里。 我用的是Python的版本。 ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:2","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"配置Shadowsocks 我平常都把配置文件放在/etc/shadowsocks/ss.json。请注意server那一项平常都改填你VPS的公网IP地址。可是如果在阿里云，等下跑的时候会报错socket.error: [Errno 99] Cannot assign requested address。原因是因为你的“真实”IP地址并不是公网IP在阿里云内，所以在socket捆绑IP和端口的时候会报错。填0.0.0.0来监听所有端口就可以了。 { \"server\":\"0.0.0.0\", \"server_port\":8080, \"local_port\":1080, \"password\":\"yourpassword\", \"timeout\":600, \"method\":\"chacha20\" } ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:3","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"可选项 安装m2crypto加解密更快一些 pip install m2crypto 如果你想用chacha20来加密，你需要安装libsodium这个包。不然的话也可以用aes-256-cfb，大多数系统都自带这个方法。 wget https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gz tar -xf libsodium-1.0.16.tar.gz \u0026\u0026 cd libsodium-1.0.16 ./configure \u0026\u0026 make -j2 \u0026\u0026 make install echo /usr/local/lib \u003e /etc/ld.so.conf.d/usr_local_lib.conf ldconfig ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:4","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"运行 当作守护进程运行 ssserver -c /etc/shadowsocks/ss.json -d start 当然也可以在前端运行，你可以看到所有代理的IP地址经过服务器。 ssserver -c /etc/shadowsocks/ss.json ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:5","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"安装Shadowsocks客户端 最后一步，在要用的设备上安装相关客户端。你可以在这里找到。苹果系统上我觉得Shadowsocks X的海外模式比较好用。 ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:6","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"网易云音乐 请选择使用IE代理。 ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:7","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"更多信息 这只是最简单的Shadowsocks服务器搭建，更多信息请查看： https://github.com/shadowsocks/shadowsocks/wiki https://shadowsocks.org/en/config/advanced.html ","date":"Mar 23 2018","objectID":"/zh-cn/proxy-server-cn-netease-music/:0:8","tags":["Practice"],"title":"搭建代理服务器以访问国内网络（网易云音乐)","uri":"/zh-cn/proxy-server-cn-netease-music/"},{"categories":null,"content":"有 \\(N\\) \\((10 \\le N \\le 100)\\) 盏亮瞎眼的灯，从 1 到 N 编号。 有四种按钮： 按钮 用途 1 反转所有的灯（开变为关，关变为开） 2 反转编号为奇数的灯（如 1，3，5） 3 反转编号为偶数的灯（如 2，4，6） 4 反转编号为 \\(3k+1 ; 当 ; k \\ge 0\\) 的灯 （如 1，4，7） 给出 \\(C\\)（按下按钮的次数, \\(0 \\le C \\le 10000\\)）和一些灯最后的状态，找出所有组不同的灯的状态。 开始时所有灯都开着，\\(C = 0\\)。 ","date":"Aug 31 2016","objectID":"/zh-cn/usaco-lamps/:0:0","tags":["USACO"],"title":"USACO Party Lamps","uri":"/zh-cn/usaco-lamps/"},{"categories":null,"content":"题解 从题意中，我们可以知道： 每6个灯是一组，因为按钮作用1，2，3的最小公倍数是6（按钮1改变每个灯，按钮2和3改变每2个灯中的一个，按钮4改变每3个灯中的1个）。 如果按下同一个按钮两次，效果和不按该按钮相同。用逻辑符号表示，\\( \\sim(\\sim p) = p \\)。一个按钮只有开或关两种可能，一共4种按钮。所以，一共有 \\( 2^4 = 16 \\) 种可能。 那么， 当 \\(C = 0\\)，检查当前状态是否符合条件。 当 \\(C = 1\\)，按下每个按钮一次。 当 \\( C \\ge 2 \\), 检查所有16种可能。 这是个练习 bitset 的好机会。原来是想把 bitset 放进 set 里的，后来发现 set 不支持对 bitset 进行排序。如果有谁知道怎么让它支持对 bitset 进行排序的，麻烦告诉我一下～ ","date":"Aug 31 2016","objectID":"/zh-cn/usaco-lamps/:0:1","tags":["USACO"],"title":"USACO Party Lamps","uri":"/zh-cn/usaco-lamps/"},{"categories":null,"content":"代码 /* ID: cepheid1 LANG: C++11 TASK: lamps */ #include\u003cfstream\u003e#include\u003calgorithm\u003e#include\u003cbitset\u003e#include\u003cvector\u003e#include\u003cmap\u003e#include\u003cset\u003e#include\u003cstring\u003eusing namespace std; ifstream fin(\"lamps.in\"); ofstream fout(\"lamps.out\"); /* convert bitset to store in map and set to get ordered */ set\u003cshort\u003e st; map\u003cshort, string\u003emp; bitset\u003c6\u003e bt; // simulates 6 lamps bitset\u003c4\u003e light; // simulates 4 buttons bool on[7], off[7]; int N, C, a; bool chk_on() { for (int i = 0; i \u003c 6 ; i++) { if (on[i] \u0026\u0026 !(bt[6-i-1])) return false; } return true; } bool chk_off() { for (int i = 0; i \u003c 6 ; i++) { if (off[i] \u0026\u0026 (bt[6-i-1])) return false; } return true; } void op(int x) { switch(x) { case 1: bt.flip(); break; case 2: for (int i = 1; i \u003c 6; i+=2) bt.flip(i); break; case 3: for (int i = 0; i \u003c 6; i+=2) bt.flip(i); break; case 4: bt.flip(2); bt.flip(5); break; default: break; } } int main(void) { fin \u003e\u003e N \u003e\u003e C; while (fin \u003e\u003e a \u0026\u0026 a != -1) { if (a%6 == 0) on[5] = true; else on[(a%6-1)] = true; } while (fin \u003e\u003e a \u0026\u0026 a != -1) { if (a%6 == 0) off[5] = true; else off[(a%6-1)] = true; } fin.close(); bt.set(); if (C == 0) { if (chk_on() \u0026\u0026 chk_off()) { if (!st.count(bt.to_ulong())) { mp[(short)bt.to_ulong()] = bt.to_string(); st.insert((short)bt.to_ulong()); } } } else if (C == 1) { for (int i = 0; i \u003c 4; i++) { bt.set(); op(i); if (chk_on() \u0026\u0026 chk_off()) { if (!st.count(bt.to_ulong())) { mp[(short)bt.to_ulong()] = bt.to_string(); st.insert((short)bt.to_ulong()); } } } } else { for (int i = 0; i \u003c 16; i++) { bt.set(); light = i; for (int j = 0; j \u003c 4; j++) { if (light[j]) op(j+1); } if (chk_on() \u0026\u0026 chk_off()) { if (!st.count(bt.to_ulong())) { mp[(short)bt.to_ulong()] = bt.to_string(); st.insert((short)bt.to_ulong()); } } } } if (st.empty()) { fout \u003c\u003c \"IMPOSSIBLE\\n\"; } else { int len = 0; string s; for (auto i : st) { len = 0; s = \"\"; while (len \u003c= N) { s += (mp[i]); len += (mp[i]).size(); } fout \u003c\u003c s.substr(0, N) \u003c\u003c endl; } } fout.close(); return 0; } ","date":"Aug 31 2016","objectID":"/zh-cn/usaco-lamps/:0:2","tags":["USACO"],"title":"USACO Party Lamps","uri":"/zh-cn/usaco-lamps/"},{"categories":null,"content":"有 \\(N\\) (\\(1 \\le N \\le 1000\\)) 个农场， 每个农场有1只奶牛去X号农场参加派对。每只奶牛都要走最短路来回。一共有 \\(M\\) (\\(1 \\le M \\le 100,000\\))单向道路，每条道路的权值为所用的时间。求往返所用的最长时间。 链接：[http://poj.org/problem?id=3268] ","date":"May 14 2016","objectID":"/zh-cn/poj-3268/:0:0","tags":["POJ","Graph"],"title":"POJ 3268 Silver Cow Party","uri":"/zh-cn/poj-3268/"},{"categories":null,"content":"题解 第一反应Floyd，观察N数据范围，复杂度 \\(V^3\\)，果断弃。 从X号农场回到各个农场比较容易，只要跑一次Dijkstra就好了。复杂度 \\(O(\\left|E\\right|log\\left|V\\right|\\))，最坏情况\\(O(\\left|E\\right|+|V|log|V|)\\)。 但是如何求各个农场到X的最短距离呢？ 我们可以把每条边反转，跑一次Dijkstra就好啦～ 所以跑两次Dijkstra就能AC啦。 ","date":"May 14 2016","objectID":"/zh-cn/poj-3268/:0:1","tags":["POJ","Graph"],"title":"POJ 3268 Silver Cow Party","uri":"/zh-cn/poj-3268/"},{"categories":null,"content":"代码 #include\u003ciostream\u003e#include\u003cqueue\u003e#include\u003calgorithm\u003e#include\u003ccstring\u003e#include\u003cfunctional\u003e#include\u003cvector\u003eusing namespace std; const int maxn = 1000+5; const int INF = 0x3f3f3f3f; typedef pair\u003cint, int\u003e P; // first: shortest path, second: vertex num; struct edge { int to, cost; }; vector\u003cedge\u003e G1[maxn]; vector\u003cedge\u003e G2[maxn]; int n, m, x; int go[maxn], back[maxn]; void dijkstra (int s, int *d, vector\u003cedge\u003e *G) { priority_queue\u003cP, vector\u003cP\u003e, greater\u003cP\u003e \u003e q; q.push(P(0, s)); while (!q.empty()) { P p = q.top(); q.pop(); int v = p.second; if (d[v] \u003c p.first) continue; for (int i = 0; i \u003c G[v].size(); i++) { edge e = G[v][i]; if (d[e.to] \u003e d[v] + e.cost) { d[e.to] = d[v] + e.cost; q.push(P(d[e.to], e.to)); } } } } int main(void) { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e x) { int u; for (int i = 1; i \u003c= n; i++) { G1[i].clear(); G2[i].clear(); } for (int i = 1; i \u003c= m; i++) { edge a; cin \u003e\u003e u \u003e\u003e a.to \u003e\u003e a.cost; G1[u].push_back(a); } fill(back, back+n+1, INF); back[x] = 0; dijkstra(x, back, G1); for (int i = 1; i \u003c= n; i++) { edge a; for (int j = 0; j \u003c G1[i].size(); j++) { a.to = i; a.cost = G1[i][j].cost; G2[G1[i][j].to].push_back(a); } } fill(go, go+n+1, INF); go[x] = 0; dijkstra(x, go, G2); int ans = -1; for (int i = 1; i \u003c= n; i++) { go[i] += back[i]; if (ans \u003c go[i]) ans = go[i]; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"May 14 2016","objectID":"/zh-cn/poj-3268/:0:2","tags":["POJ","Graph"],"title":"POJ 3268 Silver Cow Party","uri":"/zh-cn/poj-3268/"},{"categories":null,"content":"给定一个\\(N \\times N (N \\le 100)\\)的矩阵，找到最大子矩阵和。 链接： 题目UVa ","date":"Mar 24 2016","objectID":"/zh-cn/uva-108/:0:0","tags":["UVa"],"title":"UVa 108 Maximum Sum","uri":"/zh-cn/uva-108/"},{"categories":null,"content":"题解 首先想到暴力，复杂度\\(O(N^6)\\)，肯定超时。 然后有一种\\(O(N^4)\\)的解法，AC足够了。 但是可以通过把二维矩阵压到一维，复杂度\\(O(N^3)\\)的解。看题解2哟。 题解 1 用数组sum保存自原矩阵左上角到右下角坐标为\\(i, j)\\)该区域内所有数的和。 如下图所示，显然有 $$ \\begin{align} A \u0026= (A+B+C+D)\\\\ \u0026-(B+D)\\\\ \u0026-(C+D)\\\\ \u0026+D \\end{align} $$ 所以我们可以得到 A = sum[k][l] - sum[i-1][l] - sum[j-1][k] + sum[i-1][j-1]。 有个小技巧， 保存数组从 index 1 开始，初始化数组为 0 。这样可以省略边界处理。一开始样例都调不出来，找不到原因。后来发现我在 for 循环里用了 \u003c 而不是 \u003c=. #include\u003ciostream\u003e#include\u003calgorithm\u003e#define maxn 100+5 using namespace std; int v, N, sum[maxn][maxn] = {{0}}; void solve() { int MaxSum = -200; for (int i = 1; i \u003c= N; i++) { for (int j = 1; j \u003c= N; j++) { for (int k = i; k \u003c= N; k++) { for (int l = j; l \u003c= N; l++) { MaxSum = max(MaxSum, sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1]); } } } } cout \u003c\u003c MaxSum \u003c\u003c endl; } int main(void) { while(cin \u003e\u003e N) { for (int i = 1; i \u003c= N; i++) { for (int j = 1; j \u003c= N; j++) { cin \u003e\u003e v; sum[i][j] = v+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; } } solve(); } return 0; } 题解 2 在一维矩阵中，如果我们要找最大连续的区间和，状态转移方程如下： $$ d[k] = max(d[k-1]+d[k], d[k])$$ 有一个小优化就是根据贪心，我们知道如果当前的和小于0，就没有再使用它的意义了。因为加一个小于零的数肯定会减小和。 当我们知道了如何在一维中寻找最大连续区间的和，在二维中就很容易了。 设 i = 开始行数 j = 结束行数，有i \u003c= j k = 列数 我们可以把在 i 和 j 之间的所有行，以列的方式相加，储存到一维数组相应的角标下。 这样，这题就变成了一维数组求最大连续区间和了。找到的该和就是原二维数组中的长方形内所有数字的和。 #include\u003ciostream\u003e#include\u003ccstring\u003e#include\u003calgorithm\u003e#define maxn 100+5 using namespace std; int N, m[maxn][maxn], x[maxn]; int find_max() { int cur_sum=x[0], sum=0; for (int l = 0; l \u003c N; l++) { sum += x[l]; cur_sum = max(sum, cur_sum); if (sum \u003c 0) sum = 0; } return cur_sum; } void solve() { int MaxSum = -200; for (int i = 0; i \u003c N; i++) { memset(x, 0, sizeof(x)); for (int j = i; j \u003c N; j++) { for (int k = 0; k \u003c N; k++) x[k] += m[j][k]; MaxSum = max(MaxSum, find_max()); } } cout \u003c\u003c MaxSum \u003c\u003c endl; } int main(void) { while(cin \u003e\u003e N) { for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c N; j++) cin \u003e\u003e m[i][j]; solve(); } return 0; } ","date":"Mar 24 2016","objectID":"/zh-cn/uva-108/:0:1","tags":["UVa"],"title":"UVa 108 Maximum Sum","uri":"/zh-cn/uva-108/"},{"categories":null,"content":"找到第\\(n\\) \\( (1 \\le n \\le 5842)\\) 个只有2，3，5或7质因子的数。 链接： https://uva.onlinejudge.org/index.php?option=onlinejudge\u0026page=show_problem\u0026problem=384 ###题解 ####解法1 有点暴力。。。 用STL set和vector来枚举所有符合条件的数。用long long来防止爆int和栈。 #include\u003ciostream\u003e#include\u003cvector\u003e#include\u003cset\u003eusing namespace std; typedef long long ll; const int t[] = { 2, 3, 5, 7}; set\u003cll\u003e s; int main(void) { s.insert(1); set\u003cll\u003e::iterator i = s.begin(); while(s.size() \u003c 6600) { for (int j = 0; j \u003c 4; j++) s.insert((*i)*t[j]); i++; } vector\u003cll\u003e v(s.begin(), s.end()); int n; string s; while (cin \u003e\u003e n) { if (n == 0) break; if (n % 100 == 11 || n % 100 == 12 || n % 100 == 13) s = \"th\"; else if (n % 10 == 1) s = \"st\"; else if (n % 10 == 2) s = \"nd\"; else if (n % 10 == 3) s = \"rd\"; else s = \"th\"; cout \u003c\u003c \"The \" \u003c\u003c n \u003c\u003c s \u003c\u003c \" humble number is \" \u003c\u003c v[n-1] \u003c\u003c \".\\n\"; } return 0; } ####解法2 我们有： 数组 描述 a 质因子使用的次数，用来生成下一个数 num 保存4个质因子生成的数， 找到最小的填入ans数组中 ans 打表 每一个humble number \\(a\\)，一定存在一个小于\\(a\\)的humble number \\(b\\) 使得\\(\\lbrace a = kb, k \\in \\lbrace 2, 3, 5, 7\\rbrace \\rbrace\\) #include\u003ciostream\u003e#include\u003calgorithm\u003e#include\u003cstring\u003e#define maxn 5842+5 using namespace std; const int t[] = { 2, 3, 5, 7 }; int a[4] = {1, 1, 1, 1}, num[4], n, ans[maxn]; string s; int find_min() { int Min = num[0]; for (int j = 1; j \u003c 4; j++) { if (Min \u003e num[j]) { Min = num[j]; } } return Min; } int main(void) { int index = 2; ans[1] = 1; while(index \u003c maxn) { for (int i = 0; i \u003c 4; i++) num[i] = ans[a[i]]*t[i]; ans[index] = find_min(); for (int i = 0; i \u003c 4; i++) { if (ans[index] == num[i]) a[i]++; } index++; } while (cin \u003e\u003e n) { if (n == 0) break; if (n % 100 == 11 || n % 100 == 12 || n % 100 == 13) s = \"th\"; else if (n % 10 == 1) s = \"st\"; else if (n % 10 == 2) s = \"nd\"; else if (n % 10 == 3) s = \"rd\"; else s = \"th\"; cout \u003c\u003c \"The \" \u003c\u003c n \u003c\u003c s \u003c\u003c \" humble number is \" \u003c\u003c ans[n] \u003c\u003c \".\\n\"; } return 0; } ","date":"Mar 20 2016","objectID":"/zh-cn/uva-443/:0:0","tags":["UVa"],"title":"UVa 443 Humble Numbers","uri":"/zh-cn/uva-443/"},{"categories":null,"content":"\\(N\\) (\\(1 \\le N \\le 25,000\\))只蛤，每只蛤只能在特定时间段工作。 \\(T\\) (\\(1 \\le T \\le 1,000,000\\))个时间段。 找到最少蛤数能覆盖整个时间段。 链接：http://poj.org/problem?id=2376 ","date":"Mar 16 2016","objectID":"/zh-cn/poj-2376/:0:0","tags":["Greedy","POJ"],"title":"POJ 2376 Cleaning Shifts","uri":"/zh-cn/poj-2376/"},{"categories":null,"content":"助攻 每个时间段都至少要有一只蛤。 每只蛤在结束时间之后结束。比如说有两只蛤工作时间段分别是\\((1, 3)\\)和\\((4, 10)\\)。这样被认为时间段是连续的，在\\(T = 10\\)的时候是可行的。 任何时间段之间不能断。 用scanf()作为输入不然超时。 ","date":"Mar 16 2016","objectID":"/zh-cn/poj-2376/:0:1","tags":["Greedy","POJ"],"title":"POJ 2376 Cleaning Shifts","uri":"/zh-cn/poj-2376/"},{"categories":null,"content":"题解 按结束时间排序。对每个区间谈心，找到每只在当前时间段内开始，结束最晚的蛤。因为已经排过序啦，所以只要判断开始时间是不是比当前的时间小，第一个找到的就是了。 #include\u003ccstdio\u003e#include\u003cvector\u003e#include\u003calgorithm\u003eusing namespace std; typedef pair\u003cint, int\u003e P; vector\u003cP\u003e v; int N, T, ans = 0; struct cmp { bool operator()(const P \u0026l, const P \u0026r) { return l.second \u003e r.second; } }; void solve() { sort(v.begin(), v.end(),cmp()); int cur = 1; bool find = true; while (cur \u003c= T) { if ((v.size() == 0) || !find || (v[0].second \u003c cur)) { ans = -1; return ; } for (int i = 0; i \u003c v.size(); i++) { if (v[i].first \u003c= cur) { ans++; cur = v[i].second+1; printf(\"%d %d\\n\\n\", v[i].first, v[i].second); v.erase(v.begin()+i); find = true; break; } find = false; } } return ; } int main(void) { scanf(\"%d %d\", \u0026N, \u0026T); int start, end; for (int i = 0; i \u003c N; i++) { scanf(\"%d %d\", \u0026start, \u0026end); v.push_back(P(start, end)); } solve(); printf(\"%d\\n\", ans); return 0; } ","date":"Mar 16 2016","objectID":"/zh-cn/poj-2376/:0:2","tags":["Greedy","POJ"],"title":"POJ 2376 Cleaning Shifts","uri":"/zh-cn/poj-2376/"},{"categories":null,"content":"给一个5*5的数组，在里面填了整数。可选任意点作为起点，走动5次，只能往上下左右走，得到6个数字。 求有多少个不同的数字组合。 链接：http://poj.org/problem?id=3050 ","date":"Mar 14 2016","objectID":"/zh-cn/poj-3050/:0:0","tags":["POJ"],"title":"POJ 3050 Hopscotch","uri":"/zh-cn/poj-3050/"},{"categories":null,"content":"题解 用set来去重，因为只有6步和5*5的数组，dfs各个起点，加入set。 一开始用了to_string()结果CE，用了stringstreamTLE。这次终于知道sstream多慢了。。。简直龟速。。。 #include\u003ciostream\u003e#include\u003cset\u003e#include\u003cstring\u003eusing namespace std; set\u003cstring\u003e ans; int m[5][5]; const int dx[] = { 1, -1, 0, 0 }; const int dy[] = { 0, 0, 1, -1 }; string s; void dfs(int x, int y, int n) { if (n == 0) { ans.insert(s); return; } for (int i = 0; i \u003c 4; i++) { int tx = x+dx[i]; int ty = y+dy[i]; if (tx \u003e= 0 \u0026\u0026 tx \u003c 5 \u0026\u0026 ty \u003e= 0 \u0026\u0026 ty \u003c 5) { string str = s; s += m[tx][ty]; dfs(tx, ty, n-1); s = str; } } return ; } int main(void) { for (int i = 0; i \u003c 5; i++) { for (int j = 0; j \u003c 5; j++) cin \u003e\u003e m[i][j]; } for (int i = 0; i \u003c 5; i++) { for (int j = 0; j \u003c 5; j++) { s = \"\"; dfs(i, j, 6); } } cout \u003c\u003c ans.size() \u003c\u003c endl; return 0; } ","date":"Mar 14 2016","objectID":"/zh-cn/poj-3050/:0:1","tags":["POJ"],"title":"POJ 3050 Hopscotch","uri":"/zh-cn/poj-3050/"},{"categories":null,"content":"有特定顺序1到\\(N\\)个数字(\\(1\\le N \\le 10\\))，将相邻的两个数字相加得到下一行，直到只剩下一个数字。类似于杨辉三角形。 $$ 1, 2, 3 $$ $$ 3, 5 $$ $$ 8 $$ 给定\\(N\\)和最后的和sum，求字典序最小的一组整数。 链接：http://poj.org/problem?id=3187 ","date":"Mar 14 2016","objectID":"/zh-cn/poj-3187/:0:0","tags":["POJ"],"title":"POJ 3187 Backward Digits Sums","uri":"/zh-cn/poj-3187/"},{"categories":null,"content":"助攻: 注意题目是问1到\\(N\\)个整数，不是从1到10内找出所有排列。 STL中next_permutation()的结果默认是升序排列的。 ","date":"Mar 14 2016","objectID":"/zh-cn/poj-3187/:0:1","tags":["POJ"],"title":"POJ 3187 Backward Digits Sums","uri":"/zh-cn/poj-3187/"},{"categories":null,"content":"题解: 用next_permutation()生成所有可能的排列，模拟计算三角形。因为排列本来就按字典序排列，找到的第一个解就是题目的解。 #include\u003ciostream\u003e#include\u003calgorithm\u003eusing namespace std; int n, sum, ans[11], s[11]; void solve() { for (int i = 1; i \u003c= n; i++) ans[i-1] = i; if (n == 1 \u0026\u0026 ans[0] == sum) { cout \u003c\u003c sum \u003c\u003c endl; return; } do { for (int i = 0; i \u003c n-1; i++) s[i] = ans[i]+ans[i+1]; for (int i = n-2; i \u003e= 0; i--) { for (int j = 0; j \u003c i; j++) s[j] = s[j]+s[j+1]; } if (s[0] == sum) { for (int i = 0; i \u003c n; i++) cout \u003c\u003c ans[i] \u003c\u003c \" \"; cout \u003c\u003c endl; return; } } while (next_permutation(ans, ans+n)); } int main(void) { cin \u003e\u003e n \u003e\u003e sum; solve(); return 0; } ","date":"Mar 14 2016","objectID":"/zh-cn/poj-3187/:0:2","tags":["POJ"],"title":"POJ 3187 Backward Digits Sums","uri":"/zh-cn/poj-3187/"},{"categories":null,"content":"二叉树之所以叫二叉树，是因为它每一个节点都至多有两个叉，又形似一棵树。树有根，有枝，有叶，只不过一般我们在计算机中所说的树都是根在上，叶在下的。 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:0:0","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"关于树的名词 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:1:0","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"叶节点 没有任何子节点的节点。 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:1:1","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"内节点 在根节点和叶节点中间的节点。 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:1:2","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"高度和深度 树的高度和深度指的都是该树有多少层，一般从0开始数。 但是，节点的高度和深度所指的就不同了。节点的高度是指该节点到叶节点的最长距离，节点的深度是指该节点到根节点的最长距离。 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:1:3","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"二叉树类型 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:2:0","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"满二叉树 每个节点都有0或2个字子节点的树。 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:2:1","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"完全二叉树 一棵深度为\\(h\\)的树，除了第\\(h\\)层外，其他各层节点都为最大树，第\\(h\\)层的所有节点都连续地集中在左边。 总节点\\(k\\) 树高\\(h\\) \\(2^h \\le k \\lt 2^{h+1} - 1\\) \\(h = \\lfloor\\log_2k\\rfloor\\) ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:2:2","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"实现 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:3:0","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"数组 树可以用数组来存储，一般是广度优先的顺序。数组可以很好地储存完全二叉树，因为完全二叉树不会浪费数组的空间。一般来说，根节点一般储存在\\(i = 0\\), 它的子节点存在\\(i = 1\\)和\\(i = 2\\)，分别代表左节点和右节点。一个节点在\\(i\\), 它的左右节点分别在\\(2i + 1\\)和\\(2i+2\\)。但是，数组会浪费很多空间如果树不完全。 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:3:1","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"Struct 或者 Class 创建节点，与父节点关联。 struct node { int data; struct node* left; struct node* right; } ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:3:2","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"树的遍历 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:4:0","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"深度优先遍历(DFS) 遍历树按照深度优先的原则，使用递归一般在遍历中是个好主意。 先序遍历 根节点－左节点－右节点 从根节点开始 如果左子树有元素，遍历左子树，不然遍历右子树。 中序遍历 左－根－右 后序遍历 左－右－根 确定唯一的树 给定两种遍历顺序，只有两种方法能确定唯一的树。 先序遍历和中序遍历 先序遍历的第一个元素必定是树的根节点，在中序遍历中找到该节点，就能把树分为两个子树，左子树和右子树。根据左右子树的长度在先序遍历中找到对应的序列，便找到了左右子树的根节点。不断递归直到遍历树。 中序遍历和后序遍历 和上面说的类似，只是后序遍历的根节点在序列的最后。 小技巧 还有另外一种办法来记住遍历的顺序 画一条连续的线（一笔画），从根节点开始，往左画，包围整棵树，贴着节点，在根节点结束。 类别： 先序：在每个节点的左边画一个点 中序：在每个节点的下面画一个点 后序：在每个节点的右边画一个点 从根节点开始，沿着画线的顺序，碰到点的顺序就是遍历的顺序。 先序遍历 中序遍历 后序遍历 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:4:1","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"广度优先遍历(BFS) 从根节点开始，以遍历完每一层为优先原则。 ","date":"Jan 15 2016","objectID":"/zh-cn/binary-tree/:4:2","tags":["Data-Structure"],"title":"二叉树","uri":"/zh-cn/binary-tree/"},{"categories":null,"content":"栈，队列和链表是最基础的数据结构，它们出现在很多生活场景中，比如说堆起来的集装箱，排队坐过山车，人体蜈蚣（如果不知道就别去搜了，啦啦啦） ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:0:0","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"栈 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:1:0","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"简介 栈就像堆起来的集装箱，或者是一堆书，每次加入新的元素只能在旧的之上，每次移出元素只能拿出最新加入的，所以有“后进先出”的原则(后进去的元素先出来)。 常见操作有: 进栈 出栈 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:1:1","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"数组实现 一般我们用数组的第一个元素array[0]作为栈底，创建一个变量max_index来存储栈的最顶部元素在数组中的下标，也就是数组最后一个栈中元素的下标。 进栈：max_index += 1，然后在该下标插入进栈的元素 出栈：初始化在max_index下标的元素，max_index -= 1 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:1:2","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"链表实现 单向链表，用head记录栈头，每个元素都有next指向下一个元素，栈顶的next指向NULL，size纪录链表大小（栈的大小）。 进栈：让在栈顶（链表尾部）元素的next指向新的元素，新元素的next为null，size += 1 出栈：初始化栈顶（链表尾部）元素，移动到上一个元素，设置next为null, size -= 1 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:1:3","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"C++ STL - stack #include\u003ciostream\u003e#include\u003cstack\u003eusing namespace std; int main(void) { /* 创建一个栈，名为stk，元素类型为int */ stack \u003cint\u003e stk; /* 使一个元素进栈 */ stk.push(1); // 1 stk.push(2); // 1 2 /* * cout \u003c\u003c stk.push(3) \u003c\u003c endl; * 错误！！ stk.push(3) 返回void类型 */ /* top() 返回栈最顶部的元素，且不改变栈 */ cout \u003c\u003c stk.top() \u003c\u003c endl; // print out 2 stk.push(1); /* 返回栈的大小，有多少元素 */ cout \u003c\u003c stk.size() \u003c\u003c endl; // print out 3 /* 使栈顶部的元素出栈，返回void类型 */ stk.pop(); stk.pop(); cout \u003c\u003c stk.top() \u003c\u003c endl; // print out 1 /* 查看栈是否为空，如果为空，返回真(1) */ cout \u003c\u003c stk.empty() \u003c\u003c endl; return 0; } ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:1:4","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"队列 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:2:0","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"简介 队列就像排队一样，在队尾加入新的元素，在队首出队。所以队列有着“先进先出”的原则。 常见操作有： 入队 出队 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:2:1","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"链表实现 使用单向链表，用head记录队列头，每个元素都有next指向下一个元素，队尾元素的next指向NULL，size纪录队列的长度。 入队：在队尾（链表尾部）插入元素，即旧队尾的next指向新元素，新元素的next指向null，size += 1 出队：通过next移动到第二个元素，head指向第二个元素，初始化原队首（链表头部），size -= 1 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:2:2","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"C++ STL - queue 基本用法和栈相同， 信息 队列分别使用front和back来返回队首和队尾元素。 #include\u003ciostream\u003e#include\u003cqueue\u003eusing namespace std; int main() { queue\u003cint\u003e q; q.push(1); // q: 1 q.push(2); // q: 1 2 cout \u003c\u003c q.front() \u003c\u003c endl; // 1 cout \u003c\u003c q.back() \u003c\u003c endl; // 2 q.push(3); // q: 1 2 3 cout \u003c\u003c q.size() \u003c\u003c endl; // 3 q.pop(); // q: 2 3 cout \u003c\u003c q.front() \u003c\u003c endl; // 2 cout \u003c\u003c q.back() \u003c\u003c endl; // 3 cout \u003c\u003c q.empty() \u003c\u003c endl; // 0 return 0; } ### 优先队列 优先队列类似于队列，只不过每个元素都有一个优先级，出队的元素不一定是最先入队的元素，而是当前队列中优先级最高的元素。就像有人有VIP卡的可以走专属通道，有人可以插队一样，对每个元素来说并不公平，叹气。 在C++ STL中，如果把int作为优先队列的类型， 默认情况下如果是整数的优先队列，那整数越小，则优先级越低。如果想整数越大，优先级越低，可以用greater\u003cint\u003e, 完整声明std::priority_queue\u003cint, std::vector\u003cint\u003e, std::greater\u003cint\u003e q_name。如有其它需求，可自定义cmp函数来完成优先级的比较。 警告 优先队列取队首元素不再是用队列的front()，而是用top()。 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:2:3","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"链表 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:3:0","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"简介 链表像一个个回形针串起来的链子。链表有多种结构：单向链表，双向链表，循环链表等等。主要介绍单向链表，其他类型脑补脑补ok的。 常见操作有： 添加节点 销毁节点 下一节点 ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:3:1","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"C++ struct 实现 #include\u003ciostream\u003e struct Node { int value; Node *next; }; int main() { Node *root; Node *cur; /* 初始化链表 */ root = new Node; root-\u003evalue = 1; root-\u003enext = NULL; cur = root; /* 在链表尾部加入节点 */ cur = cur-\u003enext; cur = new Node; cur-\u003evalue = 2; cur-\u003enext = NULL; // linked list: 1 2 /* 在节点中间 */ Node *second = new Node; second-\u003evalue = 3; second-\u003enext = cur; root-\u003enext = second; // linked list: 1 3 2 /* 知道数据，寻找节点 */ cur = root; while (cur-\u003evalue != 3) { cur = cur-\u003enext; } std::cout \u003c\u003c cur-\u003evalue \u003c\u003c std::endl; // 3 /* 遍历到链表尾部 */ while (cur-\u003enext != NULL) { cur = cur-\u003enext; } std::cout \u003c\u003c cur-\u003evalue \u003c\u003c std::endl; // 2 /* 删除节点 */ Node *last; cur = root; if (cur == NULL) ; // empty list if (cur-\u003evalue == 1) { // if we want to delete the first node root = cur-\u003enext; delete cur; } else { while (cur-\u003evalue != 1 \u0026\u0026 cur-\u003enext != NULL) { last = cur; cur = cur-\u003enext; } if (cur-\u003evalue == 1) { last-\u003enext = cur-\u003enext; delete cur; } } } ","date":"Dec 25 2015","objectID":"/zh-cn/stack-queue-linked-list/:3:2","tags":["Data-Structure"],"title":"栈，队列和链表","uri":"/zh-cn/stack-queue-linked-list/"},{"categories":null,"content":"为什么选择 Jekyll 和 Github Pages Jekyll是一个静态网页生成器，使用YAML头信息可以很方便地使用各种布局，内置markdown，新的文章只需加入文件夹即可。Github Pages可以提供免费空间，免费无限流量来给网页当虚拟主机。他们俩配合起来相当默契，而且网上也有很多资料。但是有一点美中不足的是Github Pages是在安全模式下运行的，也就是说它并不支持Jekyll的插件。然而我们可以在本地带着插件生成好网站再放到Github上。虽然听起来不太方便，但是有脚本让我们一步实现。这点我们后面详细说。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:1:0","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"准备 了解YAML front matter可以让包含头文件的文件自动： 拥有部分或全部布局及定义的重复标签 变量 (Liquid) 如果完全不了解HTML, CSS和JavaScript, 请查看W3School，至少了解基本用法。 了解git命令，如果不请查看Git tutorial或者其他资料。希望能至少使用命令行一次了解流程，这对以后会有所帮助。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:2:0","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"创建仓库 详细步骤在这里。 如果是个人／机构网站，请使用master分支，如果是项目网站，请使用gh-pages分支 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:3:0","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"安装和初始化 步骤在Github help pages有详细解释。 完成安装后，初始化Jekyll在当前文件夹使用基本主题，运行 Jekyll new . git init 如果出现类似directory is not empty之类的错误，先把文件夹下的内容移动到该文件夹外的临时文件夹内，运行命令后再放回原来的文件即可。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:4:0","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"本地运行Jekyll和测试网站 如果您是bundler使用者，请运行bundle exec jekyll server或者bundle exec jekyll serve. 如果不是，请运行jekyll server或者jekyll serve。 让命令运行(不要用ctrl+c终止命令)，打开网页浏览器，在地址栏输入http://localhost:4000，就能看见网站啦。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:5:0","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"配置 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:6:0","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"_config.yml文件 _config.yml文件包含了网站设定，官网上有详细阐述。下面介绍基本用法: 变量 用法 title 网站名，默认下将是网站在搜索引擎出现的名字 email 在contac-list中显示的邮箱地址, 默认下出现在页脚 description 网站描述，默认下将出现在页脚 baseurl 网站的子路径, 例如设置成/blog，完整url将会变成www.pwzxxm./com/blog url 主机名和使用协议，完整url, 例如http://www.pwzxxm.com github_username twitter_username 用于链接Github和Twitter, 默认下出现在页脚 markdown 使用的markdown引擎, e.g. kramdown redcarpet highlighter 语法高亮引擎, e.g. pygments rouge permalink 设置为prettyurl将变成这样site_url/time/title 可以自定义例如/:title/ 查看详情 pagination 每页显示多少篇文章 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:6:1","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"使用自定义域名 官网提供了两个基本版的页数标示，点这里。 然而网上有适配移动端的Timble，非常赞。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:6:2","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"多语言支持 请查看Jekyll Multi Language Plugin。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:6:3","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"如使用插件，在本地生成网站 简单的说就是另外创建一个“僵尸”仓库，先生成网站，再把_site文件夹下的文件放到原根目录然后禁止Github再次生成网站。 在“僵尸”文件夹下执行bundle exec jekyll serve build or jekyll build。 复制当前文件夹下所有文件到原仓库(****.github.io), 除了README.md。 剪切原仓库的_site文件夹下所有文件到原仓库根目录。 touch .nojekyll禁止Github生成网站。 提交所有到Github。 这是bash脚本： #!/bin/bash comment=\"$1\" push_commit=\"git commit -a -m '$comment'\" # commit and push changes eval 'cd ~/git/local' # modify PATH here eval 'bundle exec jekyll build' eval 'git add .' eval $push_commit eval 'git push --all origin' # copy remove in pwzxxm.github.io eval 'cd ~/git/PwzXxm.github.io' # modify PATH here eval 'cp ./README.md ~/git/' # modify where you want to temporally put the README.md eval 'rm -rf ./*' eval 'cp -r ~/git/local/* ./' # modify PATH here eval 'cp -r _site/* ./' eval 'rm -rf _site/*' eval 'cp ~/git/README.md ./' # put the file back eval 'touch .nojekyll' # commit and push changes eval 'git add .' eval $push_commit eval 'git push --all origin' echo \"Done\" 要使用它，复制上面代码到以.sh结尾的bash脚本文件中，修改路径，给权限，运行即可。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:6:4","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"本站代码 如果想使用本站布局或想知道背后的代码，请访问 Pwzxxm.github.io local site 您可以使用关于本站的任何代码，但禁止转载本站内容。如有需要，请联系我。 ","date":"Dec 15 2015","objectID":"/zh-cn/building-blog-jekyll/:7:0","tags":["Blog","Practice"],"title":"使用Jekyll＋Github Pages搭建博客","uri":"/zh-cn/building-blog-jekyll/"},{"categories":null,"content":"PwzXxm是我的第一个网站，也是第一个博客。一开始只知道一点点基本的HTML，后来一边学CSS，JavaScript，用Jekyll东拼西凑，花了7天时间，在2015年12月10日终于把它基本上都写完了。写完的时候真是感觉能内裤外穿一垛冲天。 关于建站的详细过程[点我]({{ site.baseurl }}/cn/2015/building-blog-jekyll/)。 原来我是在看算法，刷题做ACM和看C++的，后来看着看着卡住了，想了几天也没什么头绪。我一直想着想做个网站写点东西，就先留着坑，跑来开了这个新坑。在写的过程中，好多朋友给了设计上的建议，谢谢他们～（鞠躬） 开这个博客，一个是想自己理理思路，想算法啊什么的如果能说得新手明白，那自己也应该理解得差不多了；还有就是希望别人看了这个博客能有所收获吧。因为很久以前看KMP（一个字符串匹配算法）的时候，刚开始真的是云里雾里，智商不够。后来看了好多别人写的文章，突然有一瞬间看着看着就觉得自己好像会了。谢谢那些无私写作发到博客里的大牛们，如果大牛们看见有哪写的不对的也希望能及时联系我，避免误人子弟。联系方式在每页的页脚都有显示。 大家一起加油！！！ ","date":"Dec 12 2015","objectID":"/zh-cn/the-story-about-the-blog/:0:0","tags":["Blog"],"title":"这个博客那些事","uri":"/zh-cn/the-story-about-the-blog/"}]